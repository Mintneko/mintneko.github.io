<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA Map&amp;&amp;Stream流</title>
    <url>/2021/10/13/Article10/</url>
    <content><![CDATA[<p>Map                 【重点】<br>    什么是Map<br>        Map<K,V><br>        将键映射到值的对象。 Map不能包含重复的键; 每个键可以映射最多到一个值。<br>        Map是一个双列集合，存储的每一个元素都是由两列组成，<br>        第一列我们称之为键，第二列称之为值，把这种由键和值组成的每一个元素称之为键值对。</p>
<pre><code>    &lt;K,V&gt;是泛型，K变量用于规定键存储的数据类型，V变量用于规定值存储的数据类型
                键和值的数据类型可以相同也可以不同。

                K：Key
                V：Value

Map的特点
    1、Map不能包含重复的键
        如果键重复，则值覆盖
    2、Map的值可以重复
    3、Map的键和值是一一对应的
        通过一个键只能找到唯一对应的值

Map的体系结构
    Map
        |-HashMap
        |-TreeMap

Map的常用方法
    基本方法
        V put(K key, V value)

        void clear()
        V remove(Object key)

        boolean containsKey(Object key)
        boolean containsValue(Object value)
        boolean isEmpty()

        int size()
        Collection&lt;V&gt; values()

    遍历方法
        Set&lt;K&gt; keySet()
        V get(Object key)

        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()

        default void forEach(BiConsumer&lt;? super K,? super V&gt; action)
</code></pre><p>可变参数             【重点】<br>    什么是可变参数<br>        参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了<br>        JDK5.0的新特性（自动拆装箱、增强for、泛型和可变参数）</p>
<pre><code>    方法的参数类型已经确定,个数不确定,我们可以使用可变参数
可变参数定义格式
    修饰符 返回值类型 方法名(数据类型... 变量名) &#123;
        方法体;
    &#125;

可变参数的注意事项
    1、可变参数本质上是一个数组，但是它的使用位置是有局限的，只能用在方法的形参处(定义方法时的小括号中)
    2、可变参数表示参数个数可变，我们传递实参的时候可以传递
        将多个参数存放到数组中，将数组进行传递
        0~无穷多个参数
    3、如果一个方法有多个参数，包含可变参数，可变参数要放在最后
        一个方法的可变参数只能定义一个
</code></pre><p>Stream流            【重点】<br>   什么是Stream流<br>       Stream流用于简化集合和数组操作的代码<br>       Stream流类似于生产流水线，下一步的操作都是基于上一步的，并且流水线只能一直往下一步操作，不能回头。</p>
<p>   Stream流的操作<br>        1、获取Stream流（将源数据-&gt;Stream流）<br>        2、操作Stream流<br>            中间方法<br>            终结方法<br>        3、收集Stream流（Stream流-&gt;源数据）</p>
<p>   获取Stream流（将源数据-&gt;Stream流）<br>        集合<br>            单列集合<br>                集合对象.stream();</p>
<pre><code>        双列集合
            不能直接获取,需要间接获取(先将双列集合转为单列集合，然后再获取)
            集合对象.keySet().stream();
            集合对象.entrySet().stream()
            集合对象.values().stream()

    数组
        Arrays.stream(数组名);

        Stream.of(数据1,数据2,数据3......);
</code></pre><p>   操作Stream流<br>        中间方法：<br>            Stream<T> filter(Predicate&lt;? super T&gt; predicate);<br>            Stream<T> skip(long n);<br>            Stream<T> limit(long n);<br>            public static <T> Stream<T> concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)<br>            Stream<T> distinct();</p>
<pre><code>        如果一个方法返回值还是Stream，那么这个方法就是中间方法
        流水线的中间步骤，操作完之后还可以继续操作流

    终结方法
        void forEach(Consumer&lt;? super T&gt; action);
        long count();


        如果一个方法返回值不是Stream，那么这个方法就是终结方法
</code></pre><p>   收集Stream流（Stream流-&gt;源数据）<br>         集合<br>            将Stream流中的数据收集到集合，不论是单列集合，还是双列集合使用的使用一下这个方法（Stream的方法）：<br>                <R, A> R collect(Collector&lt;? super T, A, R&gt; collector);<br>                到底收集到什么集合中，和你往方法中传递的值有关：<br>                    stream.collect(Collectors.toList()):收集到List集合中<br>                    stream.collect(Collectors.toSet()):收集到Set集合中<br>                    stream.collect(Collectors.toMap(…)):收集到Map集合中</p>
<pre><code>        单列集合
            List
                stream.collect(Collectors.toList())
            Set
                stream.collect(Collectors.toSet())

        双列集合
             stream.collect(Collectors.toMap(...)):收集到Map集合中


     数组
        Object[] toArray();
        &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA File类&amp;&amp; IO流-字节流</title>
    <url>/2021/10/13/Article11/</url>
    <content><![CDATA[<p>File类                       【掌握】<br>    什么是File类<br>        File类表示文件和目录（文件夹），在表示的时候不能只告诉程序文件或者目录的名称，<br>        应该要告诉程序文件或者目录的路径</p>
<pre><code>构造方法
    告诉程序你要操作的文件/文件夹在哪里

    File(String pathname)
    File(String parent, String child)
    File(File parent, String child)

    * 构造方法中路径的特点：
        1、可以是存在的路径也可以是不存在的
        2、可以是文件路径也可以是文件夹路径
        3、可以是相对路径也可以是绝对路径

    路径的问题
        绝对路径：以盘符开始的路径（完整的路径）

        相对路径：不以盘符开始的路径（简化/省略路径）
            当前路径相对的是项目根路径，以项目根路径为参照物

            不是所有的绝对路径都可以省略写成相对路径的，只有这个
            绝对路径中包含了项目根目录才可以写成相对路径

            项目根路径：就是你项目存放的路径+项目名

            D:\develop\JetBrains\IdeaProjects2020\javase2\a.txt     -- 绝对路径
            a.txt                                                   -- 相对路径

            D:\develop\JetBrains\IdeaProjects2020\javase2\day11\dir\a.txt    -- 绝对路径
            day11\dir\a.txt                                                  -- 相对路径

            E:\集合.xmind         -- 绝对路径，该路径不能省略为相对路径


成员方法
    对这个关联的文件/文件夹进行创建、删除、获取等操作

    创建
        文件
            boolean createNewFile()

        文件夹
            boolean mkdir()
            boolean mkdirs() :既可以创建单级也可以创建多级文件夹

    删除
        boolean delete()
            既可以删除文件也可以删除文件夹，但是删除文件夹的时候只能删除空文件夹
            删除不走回收站

    判断和获取
        public boolean isDirectory()  测试此抽象路径名表示的File是否为目录
        public boolean isFile()       测试此抽象路径名表示的File是否为文件
            * 以上这个两个方法是互斥的，不是文件就是文件夹，不是文件夹就是文件
              前提：要求文件或者文件夹是存在的，如果不存在，那么这两个方法都会返回false

        boolean exists()       测试此抽象路径名表示的File是否存在

        String getName()       返回由此抽象路径名表示的文件或目录的名称
        long length():可以获取文件的大小（字节数），不能获取到文件夹的大小
        long lastModified() ：获取到文件的最后修改时间的毫秒值
        String getAbsolutePath() ：获取绝对路径
        File[] listFiles()
</code></pre><p>IO流-字节流                   【掌握】<br>    什么是IO流<br>        输入输出流，用于处理设备（内存/硬盘[文件]）之间的数据传输</p>
<pre><code>    输入还是输出是以内存为参照物的，从外界到内存是输入，输入进行的读取操作
    从内存到外界是输出，输出进行的写出的操作


IO流的分类
    按流向分
        输入流和输出流

    按操作的数据类型分
        字节流和字符流
            非纯文本文件只能使用字节流进行操作
            纯文本文件既可以使用字节流也可以使用字符流

IO流的作用
    1、文件复制
    2、文件上传
    3、文件下载

IO流的注意事项
    1、IO流核心的每行代码都有异常，而且是编译时异常
    2、IO流相关的类，都是位于java.io包下
    3、IO流会占用系统资源，操作完之后不要忘记释放资源（关流）


字节流

    字节流的体系结构
        字节输入流
          InputStream（抽象类）
                |-FileInputStream：基本流
                |-FilterInputStream
                    |-BufferedInputStream：缓冲流

        字节输出流
            OutputStream（抽象类）
                |-FileOutputStream：基本流
                |-FilterOutputStream
                    |-BufferedOutputStream：缓冲流

    字节流的基本流
        FileOutputStream
            构造方法
                FileOutputStream(String name)
                FileOutputStream(String name, boolean append)
                FileOutputStream(File file)
                FileOutputStream(File file, boolean append)


            成员方法
                 void write(int b)：写出字节数据 int-&gt;byte
                 void write(byte[] b)
                    * write(&quot;\r\n&quot;.getBytes()) 换行

                 void write(byte[] b, int off, int len)

                 void close()



                //1.创建字节输出流的对象
                                //注意点:1、如果文件不存在,会帮我们自动创建出来，但是要求文件路径要存在
                                //      2、如果文件存在,会把文件清空，再写出到文件
                                        3、可以写相对路径，也可以写绝对路径
                                        4、关联的路径永远只能是文件路径，不能是文件夹路径
                FileOutputStream fos = new FileOutputStream(&quot;C:\\itheima\\a.txt&quot;);

                //2,写数据
                // 传递一个整数时,那么实际上写到文件中的,是这个整数在码表中对应的那个字符.
                fos.write(98);// 98(十进制)-&gt;00000000 00000000 00000000 01100010(int、二进制)
                              // -&gt;01100010(byte、二进制) -&gt;写入到文件中，但是文本编辑器是一个编解码
                              // 编解码
                                // 编码：将我们人类能看懂的文字（字符）转为计算机看得懂的（二进制）
                                // 解码：将计算机看得懂的（二进制）转为我们人类能看懂的文字（字符）


                //3,释放资源
                fos.close(); //告诉操作系统,我现在已经不要再用这个文件了


        FileInputStream
            构造方法
                FileInputStream(String name)
                FileInputStream(File file)


            成员方法
                int read()：一次读取一个字节，并返回读取到的字节，如果读取到了文件末尾，返回-1
                int read(byte[] b)：一次读取多个字节，并返回读取到数组中的有效字节个数，如果读取到了文件末尾，返回-1
                void close()



                //如果文件存在,那么就不会报错.
                //如果文件不存在,那么就直接报错.
                FileInputStream fis = new FileInputStream(&quot;bytestream\\a.txt&quot;);

                int read = fis.read();
                //一次读取一个字节,返回值就是本次读到的那个字节数据.
                //也就是字符在码表中对应的那个数字.
                //如果我们想要看到的是字符数据,那么一定要强转成char

                System.out.println((char)read);

                //释放资源
                fis.close();
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA 字符流&amp;&amp;Properties集合</title>
    <url>/2021/10/13/Article12/</url>
    <content><![CDATA[<p>字符流                 【重点】<br>    字节流的体系结构<br>        字符输入流<br>            Reader<br>                |-InputStreamReader     转换流<br>                    |-FileReader        基本流<br>                |-BufferedReader        缓冲流</p>
<pre><code>    字符输出流
        Writer
            |-OutputStreamWriter    转换流
                |-FileWriter        基本流
            |-BufferedWriter        缓冲流

编码表
    什么是编码表
        是一张现实中的文字符号等（字符）与计算机能识别的二进制（字节）之间对应表

        现实中的             计算机能识别的
        a                   01100001
        我                  11100001 10001010
        !                   01001000

    什么编解码
        编码：字符转换为字节   a-&gt;01100001
        解码：字节转换为字符   01100001-&gt;a

        编解码操作一定要查询编码表
        编解码操作使用的编码表必须是同一张，否则会出现乱码问题

    常见的编码表
        ASCII:最早的编码表，美国人和英国人的文字符号等的对应关系，不包含中文
        GBK：中文码表，一个中文占2个字节，英文、数字和符号占1个字节
        UTF-8：包含中文，一个中文占3个字节，英文、数字和符号占1个字节
        ISO-8859-1：西欧/拉丁编码，不包含中文


    &quot;我爱java&quot;（字符串） -&gt;&#39;我&#39;,&#39;爱&#39;,&#39;j&#39;,&#39;a&#39;,&#39;v&#39;,&#39;a&#39;（字符）

    &#39;我&#39;（1个字符） -&gt; &#123;-19, -29, -89&#125;（3个字节）
    字符是由字节组成的，有些是一个字节组成，有些是多个字节组成

基本流
    FileReader
        构造方法
            FileReader(String name)
            FileReader(File file)


        成员方法
            int read()：一次读取一个字符，并返回读取到的字符，如果读取到了文件末尾，返回-1
            int read(char[] chs)：一次读取多个字符，并返回读取到数组中的有效字符个数，如果读取到了文件末尾，返回-1
            void close()



            //如果文件存在,那么就不会报错.
            //如果文件不存在,那么就直接报错.
            FileReader fr = new FileReader(&quot;bytestream\\a.txt&quot;);

            int read = fr.read();
            //一次读取一个字符,返回值就是本次读到的那个字符数据.
            //也就是字符在码表中对应的那个数字.
            //如果我们想要看到的是字符数据,那么一定要强转成char

            System.out.println((char)read);

            //释放资源
            fr.close();


    FileWriter
        构造方法
                FileWriter(String name)
                FileWriter(String name, boolean append)
                FileWriter(File file)
                FileWriter(File file, boolean append)


            成员方法
                 void write(int b)：写出字符数据 int-&gt;char
                 void write(char[] b)
                 void write(char[] b, int off, int len)

                 void write(String s)
                    * write(&quot;\r\n&quot;) 换行
                 void write(String s, int off, int len)


                 void close()



                //1.创建字符输出流的对象
                                //注意点:1、如果文件不存在,会帮我们自动创建出来，但是要求文件路径要存在
                                //      2、如果文件存在,会把文件清空，再写出到文件
                                        3、可以写相对路径，也可以写绝对路径
                                        4、关联的路径永远只能是文件路径，不能是文件夹路径
                FileWriter fw = new FileWriter(&quot;C:\\itheima\\a.txt&quot;);

                //2,写数据
                // 传递一个整数时,那么实际上写到文件中的,是这个整数在码表中对应的那个字符.
                fw.write(98);// 98(十进制)-&gt;00000000 00000000 00000000 01100010(int、二进制)
                              // -&gt; 00000000 01100010(char、二进制) -&gt;写入到文件中，但是文本编辑器是一个编解码

                //3,释放资源
                fw.close(); //告诉操作系统,我现在已经不要再用这个文件了

        flush和close方法的区别
            close方法
                1、是先刷新，在关闭流
                2、close关闭流转换就不能继续使用流
            flush方法
                1、只有刷新功能
                2、可以多次调用，可以继续使用流

缓冲流
    底层提供了缓冲区（数组），提高读写的效率

     BufferedWriter
        构造方法：不能直接关联写出的文件
            BufferedWriter(Writer out)


        写和释放资源的操作与字符基本流一模一样
    BufferedReader
        构造方法：不能直接关联读取的文件
            BufferedReader(Reader in)


        读和释放资源的操作与字符基本流一模一样


     特有功能
        BufferedWriter类
            * void newLine()：一个跨平台的换行

        BufferedReader类
            * String readLine()：一次读取一行数据（不包含回车换行符），并返回，如果读取到文件末尾，返回null


    字符缓冲流的好处：
        1、提高读写的效率
        2、提供了特有功能方便操作

转换流
    InputStreamReader
        字符流 = 字节流 + 编码表

        FileReader = FileInputStream + 默认编码（UTF-8）
        InputStreamReader = FileInputStream + 指定编码表


    OutputStreamWriter
        FileWriter = FileOutputStream + 默认编码（UTF-8）
        OutputStreamWriter = FileOutputStream + 指定编码表

    作用：
        1、读写的过程中进行编码转换
        2、将字节流转换为字符流
</code></pre><p>Properties集合         【重点】<br>    什么是Properties？<br>        是一个双列集合，间接实现了Map接口。<br>        没有泛型，存储的键和值都是字符串类型<br>        它提供和IO流相结合的方法</p>
<pre><code>Properties
    共性功能            【了解】


    特有功能            【重点】
         Object setProperty(String key, String value)   相当于put方法
         String getProperty(String key)                相当于get方法         【重点】
         Set&lt;String&gt; stringPropertyNames()              相当于keySet方法
         void load(字节/字符输入流 inStream)              读取                【重点】
         void store(字节/字符输出流, String comments)     写出



    java中的配置方式
        1、配置文件方式
            .properties文件方式
            .xml文件方式

        2、注解配置方式


    Properties的使用步骤：
        1、创建Properties集合对象
        2、通过load方法读取.properties文件中的配置信息（格式：键=值）
        3、通过getProperty方法根据键获取我们需要的值。


        // 1、创建Properties集合对象
        Properties prop = new Properties();
        // 2、通过load方法读取.properties文件中的配置信息（格式：键=值）
        InputStream in = PropertiesDemo3.class.getClassLoader().getResourceAsStream(&quot;info.properties&quot;);
        prop.load(in);

        // 3、通过getProperty方法根据键获取我们需要的值。
        String username = prop.getProperty(&quot;username&quot;);// zhangsan
        String password = prop.getProperty(&quot;password&quot;);
</code></pre><p>其他流 - 对象操作流     【了解】<br>    用于操作对象的流，可以将对象直接写出到文件，也可以将文件中的对象读取出来<br>    ObjectOutputStream：对象输出流，将对象直接写出到文件<br>        构造方法<br>            ObjectOutputStream(OutputStream out)</p>
<pre><code>            * 构造方法中不能直接关联文件路径，要传递基本流对象，基本流关联文件路径

    成员方法
         void writeObject(Object obj)
            * Object obj要写出的对象


ObjectInputStream：对象输入流，将文件中的对象读取出来
    构造方法
        ObjectInputStream(InputStream in)
            * 构造方法中不能直接关联文件路径，要传递基本流对象，基本流关联文件路径

    成员方法
          Object readObject()
            * 返回的是读取到的对象


序列化和反序列化的概念
    序列化：将对象直接写出到文件
    反序列化：将文件中的对象读取出来

Serializable:标识/标记型接口

    用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？
        会出现问题，InvalidClassException无效的类异常
        该类的序列版本号与从流中读取的类描述符的版本号不匹配(写的时候的类与读取到时候看到的类不同了)

    如果出问题了，如何解决呢？
        在类中定义一个serialVersionUID常量
        ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;

        serialVersionUID常量：序列化版本号，你可以认为这是类的版本号，读和写的时候看类是否是相同的，
        就是根据serialVersionUID常量的值来判断的

        如果不显式定义serialVersionUID常量，那么系统会根据类的内容去生成一个默认的serialVersionUID


    如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？
        transient:瞬态关键字
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA 多线程1</title>
    <url>/2021/10/15/Article13/</url>
    <content><![CDATA[<h3 id="方式1，继承Thread类"><a href="#方式1，继承Thread类" class="headerlink" title="方式1，继承Thread类"></a>方式1，继承Thread类</h3><ol>
<li><p>定义一类继承Thread，并重写run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开启了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建线程对象，并调用start方法开启线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="方式2，实现Runnable接口"><a href="#方式2，实现Runnable接口" class="headerlink" title="方式2，实现Runnable接口"></a>方式2，实现Runnable接口</h3><ol>
<li><p>定义一类实现Runnable，并重写run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二种方式实现多线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Thread对象，并将Runnable对象作为构造方法的参数进行传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="方式3，实现Callable接口"><a href="#方式3，实现Callable接口" class="headerlink" title="方式3，实现Callable接口"></a>方式3，实现Callable接口</h3><ol>
<li><p>定义类实现Callable接口(指定泛型，重写call方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;跟女孩表白&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;答应&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Callable实现类对象，并将其作为参数传递给FutureTask，最后将FutureTask对象作为参数传递给Thread类的构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ft);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        String result = ft.get();  <span class="comment">// get方法带有阻塞效果，如果获取不到，会一直等待，后续代码无法执行</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：ft.get();  必须在开启线程后调用</p>
<h3 id="三种实现方式的对比"><a href="#三种实现方式的对比" class="headerlink" title="三种实现方式的对比"></a>三种实现方式的对比</h3><ul>
<li><p>编码的复杂度</p>
<p>继承Thread最简单</p>
</li>
<li><p>程序的扩展性</p>
<p>实现接口的方式扩展性相对更好</p>
</li>
<li><p>是否可以使用Thread的方法</p>
<p>第一种方式可以直接使用Thread的方法</p>
</li>
</ul>
<h3 id="获取和设置线程的名称"><a href="#获取和设置线程的名称" class="headerlink" title="获取和设置线程的名称"></a>获取和设置线程的名称</h3><ol>
<li><p>线程的默认的名称</p>
<p>规则：Thread-编号(编号是从0开始的一个数字)</p>
</li>
<li><p>获取名字</p>
<p>Thread类提供了String getName()方法</p>
</li>
<li><p>设置名称</p>
<ul>
<li>setName(String name);</li>
</ul>
</li>
</ol>
<ul>
<li>通过有参构造传递名称，需要手动重写有参构造</li>
</ul>
<h3 id="获取当前线程对象"><a href="#获取当前线程对象" class="headerlink" title="获取当前线程对象"></a>获取当前线程对象</h3><ol>
<li><p>Thread提供的静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread对象 Thread.currentThread();</span><br></pre></td></tr></table></figure>
<p>哪个线程在执行这行代码，就返回哪个线程所对应的对象</p>
</li>
</ol>
<h3 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h3><ol>
<li><p>Thread类中提供sleep方法·</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="keyword">long</span> 毫秒值);</span><br></pre></td></tr></table></figure>
<p>哪个线程在执行这行代码，哪个线程就休眠指定毫秒</p>
</li>
</ol>
<h3 id="线程的调度模型"><a href="#线程的调度模型" class="headerlink" title="线程的调度模型"></a>线程的调度模型</h3><blockquote>
<p>java中的多线程是一种抢占式的模型。多个线程争夺CPU的执行权。线程中存在一个优先级的概念，优先级越高的线程抢夺到CPU的执行权的概率理论上更高。</p>
</blockquote>
<ol>
<li><p>线程的默认优先级</p>
<p>默认是5（线程的优先级是通过数字来表示的，取值范围是1-10）</p>
</li>
<li><p>如何设置线程的优先级</p>
<p>setPriority(int priority)；</p>
</li>
<li><p>如何获取线程的优先级</p>
<p>int getPriority();</p>
</li>
</ol>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><blockquote>
<p>备胎线程：用于守护普通线程的，当普通线程直接结束，守护线程会自动结束执行。</p>
</blockquote>
<ol>
<li><p>如何将一个线程变成守护线程。</p>
<p>setDaemon(true);</p>
</li>
</ol>
<h3 id="多线程的安全问题"><a href="#多线程的安全问题" class="headerlink" title="多线程的安全问题"></a>多线程的安全问题</h3><p><strong>产生的本质原因：</strong></p>
<p>多个线程在同时操作共享数据</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p><strong>同步代码块解决</strong></p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本原理：</p>
<ol>
<li>默认锁是打开的</li>
<li>当有线程进入synchronized代码块后锁会自动锁上</li>
<li>当synchronized中的操作共享数据的代码执行完毕后，锁会自动打开</li>
</ol>
<p><strong>同步方法解决</strong></p>
<ul>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">    操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁：this</p>
</li>
<li><p>同步静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">    操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁：当前类.class（当前类字节码对象）</p>
</li>
</ul>
<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>语法</p>
<ol>
<li><p>创建Lock锁对象ReentranctLock</p>
</li>
<li><p>操作共享数据之前获取锁</p>
<p>lock();</p>
</li>
<li><p>操作完共享数据要释放锁</p>
<p>unlock();</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="comment">// 操作共享数据的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 可重入锁</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在买票,还剩下&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者生产者-等待唤醒机制"><a href="#消费者生产者-等待唤醒机制" class="headerlink" title="消费者生产者(等待唤醒机制)"></a>消费者生产者(等待唤醒机制)</h3><p>假设：消费者一共只能吃10个汉堡</p>
<ul>
<li><p>消费者线程</p>
<ol>
<li>判断桌子上是否有汉堡</li>
<li>如果桌子上没有就<strong>等待</strong></li>
<li>如果桌子上有就开吃<ul>
<li><strong>通知</strong>生产者生成汉堡</li>
<li>汉堡的数量减1</li>
</ul>
</li>
</ol>
</li>
<li><p>生产者线程</p>
<ol>
<li><p>判断桌子上是否有汉堡</p>
</li>
<li><p>如果有就<strong>等待</strong></p>
</li>
<li><p>如果没有就生产汉堡，将汉堡放在桌子上</p>
<p><strong>通知</strong>消费者线程吃汉堡</p>
</li>
</ol>
</li>
</ul>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>队列：一种先进先出的数据结构</p>
<p>阻塞队列：在传统的队列的基础上，加入了两个附加操作</p>
<ul>
<li>当获取元素的线程，发现队列为空，会自动等待，等到队列不为空为止</li>
<li>当添加元素的线程，发现队列已满，会自动等待，等待队列可用为止</li>
</ul>
<p>对象：</p>
<ul>
<li><p>ArrayBlockingQueue</p>
<p>依赖数组实现，有界的</p>
</li>
<li><p>LinkedBlockingQueue</p>
<p>依赖链表实现的，无界的，(最大长度是int的最大值)</p>
</li>
</ul>
<p>方法：</p>
<ul>
<li><p>存</p>
<p>put(元素对象)</p>
</li>
<li><p>取</p>
<p>队列顶端的元素 take();</p>
</li>
</ul>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><ol>
<li><p>能够知道什么是进程什么是线程</p>
<ul>
<li><p>进程</p>
<p>操作系统中正在执行的程序。每一个程序开始运行后，至少会有一个进程。</p>
</li>
<li><p>线程</p>
<p>线程是某一个进程中的执行逻辑。一个进程中可能包含多个线程。某一个线程只可能属于某一个进程。</p>
</li>
</ul>
</li>
<li><p>并发和并行的</p>
<ul>
<li><p>并行</p>
<p>在同一时刻，有多个指令在<strong>多个</strong>CPU上<strong>同时</strong>执行。</p>
</li>
<li><p>并发</p>
<p>在同一时刻，有多个指定在<strong>单个</strong>CPU上<strong>交替</strong>执行</p>
</li>
</ul>
</li>
<li><p>线程3种创建方式</p>
<ul>
<li>继承Thread类<ul>
<li>写一个类继承Thread，重写run方法</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>写一个类实现Runnable接口，重写run方法</li>
<li>创建Runnable的对象，并将其作为参数传递给Thread的构造方法</li>
</ul>
</li>
<li>实现Callable接口<ul>
<li>写一个类实现Callable接口，重写call方法</li>
<li>创建Callable的对象，并将其作为参数传递给FutureTask的构造方法</li>
<li>将FutureTask对象作为参数传递给Thread的构造方法</li>
</ul>
</li>
</ul>
</li>
<li><p>线程中的常见的方法</p>
<ul>
<li><p>获取线程的名称</p>
<p>getName();  默认名字：Thread-编号</p>
</li>
<li><p>设置线程的名称</p>
<p>setName(String name);</p>
<p>有参构造方法</p>
</li>
<li><p>获取当前线程对象</p>
<p>Thread Thread.currentThread();哪个线程执行到这行代码，就返回该线程对象</p>
</li>
<li><p>线程的睡眠</p>
<p>Thread.sleep(long 毫秒值)，哪个线程执行到这行代码，哪个线程就睡眠</p>
</li>
<li><p>设置线程的优先级</p>
<p>setPriority(int priority)</p>
<p>参数的取值范围：1-10，值越大优先级越大</p>
</li>
<li><p>获取线程的优先级</p>
<p>int getPriority(); 默认值是5</p>
</li>
</ul>
</li>
<li><p>守护线程</p>
<p>可以理解为备胎线程，用于守护其它的普通线程而存在。如果普通线程都执行结束，守护线程也会自动结束执行。</p>
<p>怎么将线程设置为守护线程：</p>
<p>setDaemon(true);</p>
</li>
<li><p>线程的安全问题</p>
<ul>
<li><p>什么是安全问题：</p>
<p>多个线程在并发操作共享数据时，会出现数据错乱的问题。</p>
</li>
<li><p>产生的本质原因</p>
<p>多个线程在在同时操作共享数据</p>
</li>
<li><p>解决思想</p>
<p>在同一个时刻，只能让一个线程操作功效数据，当这个线程操作完毕之后，其它线程才可以操作。</p>
</li>
<li><p>解决方式</p>
<ul>
<li><p>同步</p>
<ul>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁对象是任意的。多个线程需要使用同一个锁对象。</p>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">访问修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步方法使用this作为锁对象，同步静态方法使用 当前类.class作为锁对象</p>
</li>
</ul>
</li>
<li><p>Lock锁</p>
<ol>
<li><p>创建锁对象</p>
<p>ReentrantLock</p>
</li>
<li><p>在操作之前获取锁</p>
<p>lock();</p>
</li>
<li><p>操作之后释放锁</p>
<p>unlock(); // 一般写在finally语句块中</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁</p>
<p>多个线程出现相互等待的情况，造成程序无法继续。</p>
<p>出现的原因：锁的嵌套</p>
</li>
<li><p>生产者和消费者</p>
<p>等待唤醒机制</p>
<ul>
<li><p>让当前线程等待</p>
<p>Object类提供了一个wait();</p>
</li>
<li><p>唤醒其它线程</p>
<p>Object类提供两个方法</p>
<ul>
<li><p>notify();</p>
<p>随机换当前锁对象绑定的处于等待状态的某一个线程。</p>
</li>
<li><p>notifyAll();</p>
<p>唤醒当前锁对象绑定的所有处于等待状态的线程。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JAVA 多线程2</title>
    <url>/2021/10/20/Article14/</url>
    <content><![CDATA[<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li><p>新建</p>
<p>new 线程对象</p>
</li>
<li><p>就绪状态</p>
<p>调用线程对象的start()方法</p>
</li>
<li><p>阻塞状态</p>
<p>获取不到锁对象</p>
</li>
<li><p>等待状态</p>
<p>调用锁对象wait();方法</p>
</li>
<li><p>计时等待</p>
<p>调用Thread的sleep方法</p>
</li>
<li><p>退出状态</p>
<p>线程中的所有代码执行完毕</p>
</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>概念</p>
<blockquote>
<p>一个用于存储线程对象的容器。传统的编程，需要通过线程执行任务的时候，都是临时创建线程对象，使用完毕线程自动会处于退出状态。比较浪费时间和资源。线程池的基本思想就是将创建的线程对象存入一个容器中，需要使用线程时候从容器中获取，使用完毕之后将线程归还到容器，可以让线程对象得到<strong>复用</strong></p>
</blockquote>
<p>步骤：</p>
<ol>
<li>创建池子</li>
<li>将需要执行的任务提交给线程池</li>
<li>关闭线程池</li>
</ol>
<h4 id="创建默认线程池"><a href="#创建默认线程池" class="headerlink" title="创建默认线程池"></a>创建默认线程池</h4><ol>
<li><p>创建线程池,返回一个操作线程池的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorsService service =  Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ExecutorsService提交需要执行的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service.submit(Runnable runnable);</span><br><span class="line">service.submit(Callable callable);</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">executorService.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;在执行了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">executorService.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;在执行了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果所有线程都使用完毕，而且后续没有其他线程需要使用，则可以关闭整个线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executorService.shutDown();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="创建一个指定上限的线程池"><a href="#创建一个指定上限的线程池" class="headerlink" title="创建一个指定上限的线程池"></a>创建一个指定上限的线程池</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);<span class="comment">// 参数10代表最大线程数量</span></span><br></pre></td></tr></table></figure>
<h4 id="基于ThreadPoolExecutor创建线程池"><a href="#基于ThreadPoolExecutor创建线程池" class="headerlink" title="基于ThreadPoolExecutor创建线程池"></a>基于ThreadPoolExecutor创建线程池</h4><ol>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数详解</p>
<p>| 参数  | 解释                                                         |<br>| ——- | —————————————————————————————— |<br>| 参数1 | 核心线程数量(就算达到指定空闲时间，核心线程不会被自动回收)   |<br>| 参数2 | 最大线程数量(当达到指定的空闲时间，(最大线程数-核心线程数)的空闲线程会被自动回收，减少资源浪费) |<br>| 参数3 | 空闲时间(达到多长时间，开始进行空闲线程的回收)               |<br>| 参数4 | 时间单位，需要通过TimeUnit的枚举进行指定                     |<br>| 参数5 | 阻塞队列，当提交的线程数量超过最大最大线程数时，会将其它任务放到阻塞队列中进行排队 |<br>| 参数6 | 创建线程的工厂，线程池内部创建线程是通过线程工厂进行创建     |<br>| 参数7 | 任务的拒绝策略，当提交的任务数量超过 (最大线程数量+阻塞队列的长度) 就会触发拒绝策略 |</p>
</li>
</ol>
<h3 id="volatile问题"><a href="#volatile问题" class="headerlink" title="volatile问题"></a>volatile问题</h3><ol>
<li><p>多线程共享数据的<strong>可见性</strong>的问题：</p>
<p>当一个线程修改了共享数据的值后，其它线程不一定能够及时获取到修改后的最新值</p>
</li>
<li><p>问题产生的原因</p>
<p>线程操作共享数据时，默认是先将共享数据中的值拷贝到线程本地的变量副本中，后续的操作操作的是变量副本的值。</p>
</li>
<li><p>解决方式</p>
<ul>
<li><p>volatile关键字</p>
<p>在共享数据前面通过volatile进行修饰。强制要求线程每次都重新获取共享数据中的最新值。</p>
</li>
<li><p>synchronized关键字</p>
<p>在每次执行时，先清空变量副本，重新从共享数据中拷贝最新值到变量副本中。</p>
</li>
</ul>
</li>
</ol>
<h3 id="原子性-Atomic"><a href="#原子性-Atomic" class="headerlink" title="原子性(Atomic)"></a>原子性(Atomic)</h3><p>概念：</p>
<blockquote>
<p>一个包含多个操作的逻辑单元，要么同时执行成功，要么同时执行失败。强调的是一个逻辑单元是一个整体，不可分割。</p>
</blockquote>
<ol>
<li><p>count++问题</p>
<p>count++ 包含如下三个步骤：</p>
<ul>
<li>拷贝共享数据中的值到变量副本中</li>
<li>修改变量副本中的值(+1)</li>
<li>将变量副本中的值重新赋值给共享数据</li>
</ul>
<p>在执行到任意步骤的时候都可能会被其它线程打断，最终造成数据有误。所以count++的操作不是原子性的。</p>
</li>
<li><p>原子性问题产生的本质原因：</p>
<p>一个线程中的某个操作可能包含多个步骤，在执行到某一步的时候被其它线程给打断。</p>
</li>
<li><p>为什么synchronized能够解决原子性的问题：</p>
<p>加锁之后，不会出现多个线程同时操作共享数据的问题。操作不可能被打断，所以肯定不会出现问题。</p>
</li>
</ol>
<h3 id="原子类AtomicInteger"><a href="#原子类AtomicInteger" class="headerlink" title="原子类AtomicInteger"></a>原子类AtomicInteger</h3><p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建AtomicInteger对象</span></span><br><span class="line">    <span class="comment">// AtomicInteger integer = new AtomicInteger(); // 初始值默认为0</span></span><br><span class="line">    AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">10</span>);</span><br><span class="line">    System.out.println(integer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取值并自增的方法(返回的原始值)</span></span><br><span class="line">    <span class="keyword">int</span> value = integer.getAndIncrement();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    System.out.println(integer.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取值并自增的方法(返回的自增后的值)</span></span><br><span class="line">    <span class="keyword">int</span> value2 = integer.incrementAndGet();</span><br><span class="line">    System.out.println(value2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取值并设置新的值(返回的是原来的值)</span></span><br><span class="line">    <span class="keyword">int</span> value3 = integer.getAndSet(<span class="number">20</span>);</span><br><span class="line">    System.out.println(value3);</span><br><span class="line">    System.out.println(integer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><blockquote>
<p>compare and swarp</p>
</blockquote>
<p>核心：在修改共享数据(内存值)的时候比较线程中记录的获取到旧值和共享数据中的内存值是否一致</p>
<ol>
<li>如果一致，证明没有其他线程操作过内存值，那么直接进行修改</li>
<li>如果不一致，证明已经有其它线程操作过内存值，那么需要重新将最新值获取到，重新进行操作。这个操作叫自旋。</li>
</ol>
<h3 id="ConcurrentHashMap-jdk1-7原理"><a href="#ConcurrentHashMap-jdk1-7原理" class="headerlink" title="ConcurrentHashMap jdk1.7原理"></a>ConcurrentHashMap jdk1.7原理</h3><ul>
<li><p>创建对象时</p>
<ol>
<li>创建固定长度为16的大数组，加载因子是0.75</li>
<li>创建了一个长度为2的小数组，并将其地址值赋值给大数组的0索引</li>
</ol>
</li>
<li><p>存入元素时</p>
<ol>
<li>根据键的hash值，计算出在大数组中的索引</li>
<li>判断大数组对应的索引值是否是null<ul>
<li>是 null<ul>
<li>以大数组0号索引为模板创建长度为2的小数组，将其地址值赋值大数组的当前索引</li>
<li>会根据键进行二次hash，计算出小数组中的索引，直接存入</li>
</ul>
</li>
<li>不是null<ul>
<li>根据地址值找到小数组</li>
<li>会根据键进行二次hash，计算出小数组中的索引，判断是否需要扩容，如果需要则扩容两倍</li>
<li>判断小数组的索引位置是否为null<ul>
<li>如果为null，直接存入</li>
<li>如果不为null，调用equals方法判断属性值是否一致<ul>
<li>如果一致，不会进行存入</li>
<li>如果不一致，将元素存入小数组的对应索引，将老的元素挂载到下面形成hash桶结构</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>如何解决安全问题</p>
<p>当有一个线程在操作大数组中的某一个索引时，会将对应索引下的小数组锁住。其它索引的位置，还是可以被其它线程操作。</p>
</li>
</ul>
<h3 id="ConcurrentHashMap-jdk1-8原理"><a href="#ConcurrentHashMap-jdk1-8原理" class="headerlink" title="ConcurrentHashMap jdk1.8原理"></a>ConcurrentHashMap jdk1.8原理</h3><ol>
<li>如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。<br>在第一次添加元素的时候创建哈希表</li>
<li>计算当前元素应存入的索引。</li>
<li>如果该索引位置为null，则利用cas算法，将本结点添加到数组中。</li>
<li>如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。</li>
<li>当链表的长度大于等于8时，大数组的长度等于64，自动转换成红黑树</li>
<li>以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性</li>
</ol>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>应用场景：某一个线程需要等待其它线程之后完毕之后再执行</p>
<p><img src="多线程day02.assets\image-20211018165524678.png" alt="image-20211018165524678"></p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>应用场景：控制同时执行的线程的数量</p>
<p>编码步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景Semaphore对象，并且传入允许同时执行线程数量</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(数量);</span><br><span class="line"></span><br><span class="line">run()&#123;</span><br><span class="line">    semaphore.acquire(); <span class="comment">// 获取许可证(如果能够获取到，数量会减1，如果数量为0，则获取不到，那么代码会在这一行阻塞)</span></span><br><span class="line">    <span class="comment">//需要执行的核心代码</span></span><br><span class="line">    <span class="comment">//需要执行的核心代码</span></span><br><span class="line">    semaphore.release(); <span class="comment">// 归还许可证(数量会加1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><ol>
<li><p>线程的状态，状态切换</p>
<ul>
<li><p>新建</p>
<p>创建线程对象</p>
</li>
<li><p>就绪</p>
<p>调用start方法</p>
</li>
<li><p>阻塞</p>
<p>获取不到锁</p>
</li>
<li><p>等待</p>
<p>wait()方法</p>
</li>
<li><p>计时等待</p>
<p>sleep()方法</p>
</li>
<li><p>退出</p>
<p>run方法中的代码执行完毕</p>
</li>
</ul>
</li>
<li><p>线程池</p>
<ul>
<li><p>概念</p>
<p>用于存储线程对象的容器。当我们需要执行任务的时候，只需要将任务提交给线程池，线程池会自动创建线程执行任务。当线程使用完毕后，会将线程归还到线程池中，方便复用。</p>
</li>
<li><p>Executors创建线程池</p>
<ul>
<li><p>创建默认的线程池</p>
<p>ExecutorService  service = Executors.newCachedThreadPool();</p>
</li>
<li><p>创建有上限的线程池</p>
<p>ExecutorService  service = Executors.newFixedThreadPool(最大数量);</p>
</li>
<li><p>通过ExecutorService  执行任务</p>
<p>service.submit(Runnable r);</p>
<p>service.submit(Callable c)；</p>
</li>
<li><p>销毁线程池</p>
<p>service.shutdown();</p>
</li>
</ul>
</li>
<li><p>ThreadPoolExecutor创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">	核心线程数量,</span><br><span class="line">    最大线程数量,</span><br><span class="line">    空闲线程的最大空闲时间,</span><br><span class="line">    时间单位(TimeUnit),</span><br><span class="line">    阻塞队列，</span><br><span class="line">    创建线程的工厂，Executors.defaultThreadFactory();,</span><br><span class="line">    拒绝策略ThreadPoolExecutor.AbortPolicy();</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>volatile问题</p>
<ul>
<li><p>可见性问题</p>
<p>当一个线程修改了共享数据中的值，另一个线程可能无法获取到最新的值</p>
</li>
<li><p>产生原因</p>
<p>默认情况下，线程操作共享数据时，先拷贝共享数据中的值到变量副本中，后续的操作是操作变量副本。</p>
</li>
<li><p>解决办法</p>
<ul>
<li><p>volatile关键字</p>
<p>在共享数据的数据类型前添加volatile，强制要求线程每次操作都去获取最新值</p>
</li>
<li><p>synchronized关键字</p>
<p>每次操作时，先清空变量副本，需要重新获取最新值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原子性</p>
<ul>
<li><p>概念</p>
<p>一个包含多个操作的逻辑单元，要么同时成功，要么同时失败。这一个逻辑单元是一个不可分割的整体。</p>
</li>
<li><p>count++的问题</p>
<ul>
<li><p>count++底层的操作过程：</p>
<ol>
<li>获取到共享数据中的内存值，存入变量副本</li>
<li>对变量副本中的值进行+1</li>
<li>将最新的值重新赋值给共享数据</li>
</ol>
</li>
<li><p>上述的3个步骤，执行到任意一步，都有可能被其它线程中断。</p>
</li>
<li><p>解决方式</p>
<ol>
<li><p>synchronized关键字</p>
<p>加锁后，同一时刻只有一个线程在操作共享数据，所以不可能被其它线程中断。</p>
</li>
<li><p>原子类AtomicInteger</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>AtomicInteger使用</p>
<ul>
<li><p>创建对象</p>
<p>AtomicInteger i = new AtomicInteger(); // 默认值是0</p>
<p>AtomicInteger i = new AtomicInteger(初始值); </p>
</li>
<li><p>核心方法</p>
<ul>
<li><p>int get(); </p>
<p>获取值</p>
</li>
<li><p>int getAndIncrement();</p>
<p>获取旧值，并自增</p>
</li>
<li><p>int incrementAndGet();</p>
<p>先自增，并获取新值</p>
</li>
<li><p>int getAndSet(int value);</p>
<p>获取旧值，并重新设置新值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CAS算法</p>
<ul>
<li><p>概念</p>
<p>Compare And Swarp 算法</p>
</li>
<li><p>核心原理</p>
<ul>
<li><p>获取共享数据中的旧值，并且将其记录到线程中</p>
</li>
<li><p>操作变量副本中的值</p>
</li>
<li><p>在将变量副本中的最新的值，赋值给共享数据之前，会检查线程中记录的旧值和共享数据中的值是否一致</p>
<ul>
<li><p>相同</p>
<p>没有其他线程操作过共享数据，直接修改</p>
</li>
<li><p>不相同</p>
<p>证明其他线程已经操作过共享数据，重新获取共享数据的值，到线程中，重新操作。这个操作叫做自旋</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>并发工具包下的常见类</p>
<ul>
<li><p>ConcurrentHashMap</p>
<ul>
<li><p>概念</p>
<p>jdk1.5版本中提供的一种兼顾性能和安全的集合类</p>
</li>
<li><p>使用</p>
<p>和传统的hashmap没有区别</p>
</li>
<li><p>在jdk1.7和jdk1.8底层实现原理的区别</p>
</li>
</ul>
</li>
<li><p>CountDownLatch</p>
<ul>
<li><p>作用</p>
<p>实现让某一个线程在其它的线程执行完毕之后再执行</p>
</li>
<li><p>核心方法</p>
<ul>
<li><p>创建对象</p>
<p>CountDownLatch latch = new CountDownLatch (等待线程数量)；</p>
</li>
<li><p>被等待的线程</p>
<p>当核心代码执行完毕之后，调用latch .countDown();</p>
</li>
<li><p>等待的线程</p>
<p>在执行核心代码前，调用latch.await();</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Semaphore</p>
<ul>
<li><p>作用</p>
<p>限定同时执行的线程的数量</p>
</li>
<li><p>核心方法</p>
<ul>
<li><p>创建对象</p>
<p>Semaphore s = new Semaphore(允许的线程数量)</p>
</li>
<li><p>线程中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.acquire(); <span class="comment">// 获取许可证（计数器-1，如果计数器的值等于0，则无法获取徐克成）</span></span><br><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line">s.release(); <span class="comment">// 归还许可证(计数器+1)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>代码块&amp;&amp;接口&amp;&amp;多态</title>
    <url>/2021/10/12/Article3/</url>
    <content><![CDATA[<p>代码块             【掌握】<br>    什么是代码块<br>        就是使用一对大括号包裹起来的代码<br>        {}</p>
<pre><code>Java中的代码块分类(只有这4种)
    局部代码块
    构造代码块
    静态代码块
    同步代码块（多线程讲解）


每种代码块的使用
    局部代码块
        格式：
            &#123;

            &#125;
        位置：位于方法中

        特点：定义的变量只能代码块中使用，出了大括号就无法使用

        作用：就是限制变量的作用域，让变量使用完及早释放，节省内存

    构造代码块
        格式：
            &#123;

            &#125;

        位置：位于类中方法外

        特点：每一次调用构造方法的时候，都会执行一次构造代码块，而且是先执行
             本类构造代码块先于本类构造方法执行

        作用：抽取多个构造方法中的共性代码块

    静态代码块
        格式：
            static&#123;

            &#125;

        位置：类中方法外

        特点：随着类的加载而执行，执行时机早  -- 验证一个类是否被加载，什么时候加载
             类的加载只会加载一次，静态代码块也只会执行一次 --一次性的操作，比如说读取配置文件

             先于构造代码块执行
             先于本类的main方法执行

        作用：执行一些很早且一次性的操作，比如一些初始化操作，读取配置文件，加载数据库驱动等
</code></pre><p>接口               【掌握】<br>    什么是接口<br>        就是使用interface关键字定义的一种特殊的类<br>        它比抽象类更加抽象，因为其中的方法只能是抽象方法（JDK8以前）</p>
<pre><code> 接口的好处
    1、定义规则
    2、提高程序的扩展性

接口定义格式
    public interface 接口名 &#123;

    &#125;
接口使用格式
    1、类实现该接口
        public class 类名 implements 接口名 &#123;

        &#125;

    2、接口继承接口


接口的特点
    1、接口不能创建对象（实例化）
    2、类去实现接口的时候，要么重写（实现）其中所有的抽象方法，要么这个类定义为抽象类


接口的成员的特点
    1、变量
        成员变量：不能有
        常量:可以有，有默认修饰符:public static final

    2、构造方法
        没有构造方法

        构造方法的作用：
            （1）创建对象（成员变量赋值）
            （2）子类构造方法调用

    3、成员方法
        抽象方法：可以有，有默认修饰符：public abstract
        非抽象方法：可以有(JDK8及其之后)



 接口的升级（接口新特性）
    默认方法（JDK8）
        格式：
            public default 返回值类型 方法名(参数列表)&#123;

            &#125;

        特点
            1、可以被实现类所继承
            2、不要求强制重写，也可以重写

        作用
            解决接口的升级问题

    静态方法（JDK8）
        格式：
            public static 返回值类型 方法名(参数列表)&#123;

            &#125;

        特点
            1、不能被实现类所继承，不能创建实现类对象的方法调用，也不能通过实现类类名.方式调用
            2、只能通过接口名.的方式进行调用

        作用
            解决接口的升级问题

    私有方法（JDK9）
        格式：
            // 私有默认方法
            private 返回值类型 方法名(参数列表)&#123;

            &#125;

            // 私有静态方法
            private static 返回值类型 方法名(参数列表)&#123;

            &#125;

        特点
            1、不能被实现类继承，也不能为外类使用
            2、只能通过在接口内部通过非抽象的方法（默认、静态和私有方法）进行调用

        作用
            抽取接口内部默认方法和静态方法的共性代码

    注：
        接口的升级，只是针对方法进行的，对成员变量和构造方法没有改变
        这些方法都是非抽象方法，有方法体

        以后我们在接口主要还是定义抽象的方法，极少定义非抽象方法
        但是我们在使用的过程中，可能会使用JDK提供的一些接口，其中定义这些类型的非抽象方法
        我们只要会使用这些方法即可。

类和接口之间的关系
    类和类之间
        extends，继承关系，只能单继承，不支持多继承，可以多层继承
    类和接口之间
        implements，实现关系，可以单实现，可以多实现，可以多层实现
        一个类可以在继承一个类的同时，实现多个接口
        class A extends B implments C,D &#123;

        &#125;
    接口和接口之间
        extends，继承关系，可以单继承，多继承和多层继承
</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">接口和抽象类的区别</span><br><span class="line">    1、定义方式不同</span><br><span class="line">        接口：interface关键字定义的</span><br><span class="line">        抽象类：abstract class关键字定义的</span><br><span class="line"></span><br><span class="line">    2、类的成员不同</span><br><span class="line">        接口：</span><br><span class="line">            没有成员变量，可以有常量，常量有默认修饰的</span><br><span class="line">            没有构造方法</span><br><span class="line">            只能有抽象方法（JDK8以前）抽象方法有默认修饰符的，</span><br><span class="line">                从JDK8以及之后也可以定义非抽象方法</span><br><span class="line">                但是其非抽象方法只能定义成三种（默认、静态、私有）</span><br><span class="line">         抽象类</span><br><span class="line">            可以有成员变量，可以有常量，但是常量没有默认修饰符，必须自己手动加上final关键字</span><br><span class="line">            有构造方法</span><br><span class="line">            可以有抽象方法，也可以有非抽象方法，不要求修饰符一定要使用默认、静态、私有来修饰</span><br><span class="line"></span><br><span class="line">    3、和类之间的关系不同</span><br><span class="line">        接口：</span><br><span class="line">            类实现接口，实现关系，使用implements关键字</span><br><span class="line"></span><br><span class="line">        抽象类</span><br><span class="line">            类继承抽象类，继承关系，使用extends关键字</span><br><span class="line"></span><br><span class="line">    4、设计思路不同</span><br><span class="line">        接口：</span><br><span class="line">            定义规则(抽象方法就是规则)</span><br><span class="line">            提高程序扩展性(实现可插拔)</span><br><span class="line"></span><br><span class="line">            也是可以对多个类的共性向上抽取的，但是只能抽取方法，不能抽象成员变量</span><br><span class="line"></span><br><span class="line">        抽象类</span><br><span class="line">            当做父类来使用，可以给子类继承一部分方法，也可以定义抽象方法，让子类自己实现</span><br><span class="line"></span><br><span class="line">            可以对多个类的共性向上抽取，但是它可以抽取共性方法和成员变量</span><br><span class="line">            </span><br><span class="line">	进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘</span><br><span class="line">    USB接口，包含开启功能、关闭功能</span><br><span class="line">    笔记本类，包含运行功能、关机功能、使用USB设备功能</span><br><span class="line">    鼠标类，要实现USB接口，并具备点击的方法</span><br><span class="line">    键盘类，要实现USB接口，具备敲击的方法</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>多态&amp;&amp;内部类&amp;&amp;匿名内部类&amp;&amp;Lambda表达式</title>
    <url>/2021/10/13/Article4/</url>
    <content><![CDATA[<p>多态                          【掌握】<br>    什么是多态<br>        是一个事物表现出来的多种形态<br>            猫/狗 也可以说是动物<br>            摩托车 也可以说是机动车<br>            学生  也可以说成是人</p>
<pre><code>        面试题：以下诗词体现的是面向对象的哪种特征
            苏轼曰：横看成岭侧成峰，远近高低各不同

            体现了多态的特征


    在Java中的多态，是一个对象表现出来的多种形态
        // 狗是狗
        Dog d = new Dog();
        // 狗是动物，体现了多态
        Animal a = new Dog();

        体现在：父类的引用指向子类的对象
                父类类型的变量去记录子类对象的地址


多态的前提
    1、有继承/实现关系
    2、一般会有方法重写
    3、父类的引用指向子类的对象
        接口的引用指向实现类的对象

多态下的成员访问特点
    成员变量
        编译看左边（父类），运行看左边（父类）

    成员方法
        非静态的成员方法
            编译看左边（父类），运行看右边（子类）
        静态的成员方法
             编译看左边（父类），运行看左边（父类）

    总结：编译都看左边（父类），只有非静态的成员方法运行的时候看右边（子类），其余都看左边

多态的优缺点
    优点：
        提高程序扩展性

    缺点：
        无法使用子类特有成员

多态的类型转换
    这里的类型转换指的是引用类型的转换，基础班学习的类型转换是基本类型的转换
    向上转型：类似于基本类型转换中的隐式转换/自动类型提升，子类类型转换为父类类型，父类引用指向子类对象就是向上转型
            Animal a = new Dog();
    向下转型：类似于基本类型转换中的强制转换，父类类型转换为子类类型
                子类类型 变量名 = (子类类型)父类类型的值;
                Dog d = (Dog)a;

向下转型中的问题和解决
    类型转换异常：ClassCastException

    解决：先判断，是这种类型，再转换
        判断：instanceof运算符

        boolean flag = 对象（名） instanceof 类;


多态的应用场景
    1、创建的对象时候
         Animal a = new Cat();
         private BaseStudentDao studentDao = StudentDaoFactory.getStudentDao();

    2、方法参数传递
        public static void useAnimal(Animal a)&#123;

        &#125;

        useAnimal(new Dog());
        useAnimal(new Cat());

    3、方法的返回值
        public static BaseStudentDao getStudentDao() &#123;
            return new StudentDao();
    //        return new OtherStudentDao();
        &#125;


方法的参数传递：方法要什么类型就传什么类型，要几个参数就传几个参数
参数是基本类型
参数是引用类型
    数组
    类：Student Dog Animal String
    接口：Jump Inter BaseStudentDao List

    如果形参是数组，就传递对应类型的数组对象即可
    如果形参是类类型，就传递该类的对象，或者该类的子类对象
        如果类是一个抽象类，则只能传递该类的子类对象，因为抽象类无法创建对象
    如果形参是接口类型，则只能传递该接口的实现类对象，因为接口无法创建对象
</code></pre><p>内部类<br>    成员内部类               【了解】<br>        直接定义在类中方法外的类，在类的成员位置定义的<br>        注：以后我们基本上不会编写和使用成员内部类，只要以后查看源码看到了能知道这是内部类即可</p>
<pre><code>    内部类的访问特点
        内部类可以直接访问外部类的成员，包括私有
        外部类要访问内部类的成员，必须创建对象
    外界创建成员内部类格式
        格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;
        举例：Outer.Inner oi = new Outer().new Inner();

    可以在类中直接定义的内容
        成员变量
        成员方法
        构造方法
        成员内部类（内部接口、内部枚举）
        代码块（静态代码块、构造代码块）

局部内部类               【了解】
    直接定义在方法中的类，在类的局部位置定义的
    注：以后我们基本上不会编写、使用成员内部类，甚至见都见不到



匿名内部类               【掌握】
    什么是匿名内部类
        就是一个没有名字的局部内部类

    作用
        简化代码块，将类的继承/实现、方法重写、对象创建者三步一起完成

    格式
        new 类/接口名() &#123;

            // 方法的重写或者实现
        &#125;;


        类/接口类型 变量名 = new 类/接口名() &#123;

            // 方法的重写或者实现
        &#125;;


        匿名对象：没有名字的对象，没有变量引用的对象
                    new Student();
        匿名内部类：没有名字的类
            匿名内部类的匿名对象：创建的匿名内部类的对象没有使用一个变量来接收这个对象


    原理
        匿名内部类是在创建该类的子类对象，或者创建该接口的实现类对象


    匿名内部类的使用场景
        一切需要该类的子类对象，或者该接口的实现类对象的场景大部分都是可以使用匿名内部类的

        1、调用方法当做实参
        2、当做方法的返回值
        3、直接多态的方式创建该类的子类对象，或者该接口的实现类对象
</code></pre><p>Lambda表达式<br>    作用：简化代码，可以对部分匿名内部类的代码做进一步的简化</p>
<pre><code>Lambda表达式的使用前提
    1、必须是一个接口
    2、这个接口中有且只有一个抽象方法

    有且只有一个抽象方法的接口，称之为函数式接口(FunctionalInterface)
    可以通过一个@FunctionalInterface注解来验证接口是否是函数式接口

    Lambda表达式的原理：创建接口的实现类对象

Lambda表达式的格式
    标准格式
        () -&gt; &#123;&#125;

        ()：指的是接口的抽象方法的形式参数
        -&gt;：传递的意思，固定的格式
        &#123;&#125;：实现了抽象方法之后的方法体内容

    省略格式
        () -&gt; &#123;&#125;
        规则：
          ()：
            0个参数：小括号不能省略
            1个参数：小括号和数据类型可以省（如果要省略小括号，则一定要省略数据类型）
            2个及其以上参数：只能省略数据类型，不能省略小括号

          -&gt;：不能省略

          &#123;&#125;：
            只有一行语句的时候才可以省略，可以省略&#123;&#125;、return和语句结尾的分号，要省则三者同时省
            如果一行以上的语句则不可以省略
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA中API的使用</title>
    <url>/2021/10/13/Article5/</url>
    <content><![CDATA[<p>  API<br>        Math类               【重点】<br>        System类             【重点】<br>        Object类             【重点】<br>        Objects类<br>        BigDecimal类         【重点】<br>        包装类（Integer类）   【重点】<br>        Arrays类             【重点】</p>
<pre><code>数组的高级操作             【重点】
    二分查找
    冒泡排序
    快速排序

递归                      【重点】
</code></pre><p>如何使用API文档<br>    1、打开文档<br>    2、点击索引选项卡，输入类名，最后回车，就能显示该类的详细描述信息<br>    3、查看描述信息<br>        （1）看包<br>            在java.lang包下的类不需要导包<br>            其余都需要导包<br>        （2）类的描述信息<br>            其中会描述类的信息，类的注意事项，使用方式，它的方法等….<br>        （3）看构造方法           【<strong>*</strong>】<br>            用于创建对象<br>        （4）看成员方法            【<strong>*</strong>】<br>            作用<br>            名称<br>            参数<br>            返回值<br>            注意事项<br>            …</p>
<pre><code>步骤：
    静态的成员方法（类名.进行调用）
        学习成员方法

    非静态的成员方法
        1、学习构造方法
        2、学习成员方法
</code></pre><p>Math类               【重点】<br>    工具类的特点：<br>        1、所有的方法都是static修饰的<br>        2、构造方法使用private修饰（私有化）</p>
<pre><code>成员方法
    public static int abs(int a) 返回参数的绝对值
    public static double ceil(double a)返回大于或等于参数的最小double值，等于一个整数
    public static double floor(double a)返回小于或等于参数的最大double值，等于一个整数
    public static int round(float a) 按照四舍五入返回最接近参数的int
    public static int max(int a,int b) 返回两个int值中的较大值
    public static int min(int a,int b) 返回两个int值中的较小值
    public static double pow (double a,double b)返回a的b次幂的值
    public static double random() 返回值为double的正值，[0.0,1.0)
</code></pre><p>System类             【重点】<br>    成员方法<br>        static void exit(int status)<br>        static long currentTimeMillis()<br>        static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>Object类             【重点】<br>    是所有类的父类、基类、超类、根类或者祖先类。</p>
<pre><code> String toString() ：将一个对象转为字符串返回。
    * 一个类中如果没有重写toString方法，会默认继承Object类中的toString方法
      Object类中的toString方法转换的字符串的格式：全类名@地址值的十六进制（com.itheima.demo1.Student@3f3afe78）
      但是得到的字符串是这种格式没有什么意义，我们希望得到的字符串中能反映对象中的内容，所以我们基本上
      会对Object类中继承的toString方法进行重写，使用快捷键重写即可。


 boolean equals(Object obj) ：比较两个对象是否相等
    一个类中如果没有重写equals方法，会默认继承Object类中的equals方法
    Object类中的equals方法比较的是两个对象的地址是否相等，底层使用是==号进行比较
    但是equals比较地址的功能一般我们不会需要，如果要比较地址，我们就直接使用==即可，所以基本上我们都会
    对equals方法进行重写，重写之后是比较两个对象中的内容是否相等，使用快捷键重写即可


    面试题：==和equals的区别
        ==是比较运算符，既可以比较基本类型的数据，也可以比较引用类型的数据
        比较基本类型的数据，比较的是值是否相等
        比较引用类型的数据，比较的是地址值是否相等

        equals是一个方法，只能比较引用类型的数据，不能比较基本类型的数据
        比较引用类型的数据，默认比较的是地址值，
        但是一般都会重写equals方法，比较的就是对象中的内容是否相等
        比如：String就重写了equals方法，比较的是两个字符串对象的内容是否相等
</code></pre><p>BigDecimal类         【重点】<br>    可以进行精确运算，对数据敏感的项目（银行 证券类）会使用到这个类<br>    构造方法<br>        BigDecimal(double val)<br>        BigDecimal(String val)    【推荐】</p>
<pre><code>成员方法
    public BigDecimal add(另一个BigDecimal对象) 加法
    public BigDecimal subtract (另一个BigDecimal对象) 减法
    public BigDecimal multiply (另一个BigDecimal对象) 乘法
    public BigDecimal divide (另一个BigDecimal对象) 除法
    public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式)
</code></pre><p>包装类（Integer类）   【重点】<br>    什么是包装类<br>        基本类型（4类8种）对应的引用类型<br>        Java是面向对象的语言，将基本类型的数据也是封装成了对象，这样就更加的方便对这些数据进行操作。</p>
<pre><code>基本类型对应的包装类
    基本类型        包装类类型
    byte            Byte
    short           Short
    int             Integer
    long            Long
    float           Float
    double          Double
    char            Character
    boolean         Boolean

Integer类
    自动拆装箱
        JDK5.0的新特性
        装箱：将基本类型的数据转为包装类类型
        拆箱：将包装类类型的数据转为基本类型

        JDK5.0之后装箱和拆箱都可以自动完成，称之为自动拆装箱
        自动装箱底层原理：是在调用valueOf方法,
            Integer i1 = 100;
            相当于
            Integer i1 = Integer.valueOf(100);
        自动拆箱底层原理：是在调用intValue方法
            int i2 = i1;
            相当于
            int i2 = i1.intValue();

    int和String的互转
        int转String
            + &quot;&quot;

        String转int
            Integer.parseInt(&quot;10&quot;);



    public class MyIntegerDemo6 &#123;
        public static void main(String[] args) &#123;
            Integer i1 = 100;// Integer.valueOf(100)
            Integer i2 = 100;// Integer.valueOf(100)
            System.out.println(i1 == i2);// ?           true
            System.out.println(i1.equals(i2));// true

            Integer i3 = new Integer(100);
            Integer i4 = new Integer(100);
            System.out.println(i3 == i4);// false
            System.out.println(i3.equals(i4));// true

            System.out.println(&quot;--------------&quot;);

            Integer i5 = 200;// Integer.valueOf(200)
            Integer i6 = 200;// Integer.valueOf(200)
            System.out.println(i5 == i6);// ?               false
            System.out.println(i5.equals(i6));// true

            Integer i7 = new Integer(200);
            Integer i8 = new Integer(200);
            System.out.println(i7 == i8);// false
            System.out.println(i7.equals(i8));// true
        &#125;
    &#125;
</code></pre><p> 数组的高级操作             【重点】<br>        二分查找</p>
<pre><code>    冒泡排序
    快速排序
</code></pre><p>递归<br>    就是方法调用自身的过程</p>
<pre><code>递归的分类
    直接递归
    a() &#123;
        a();
    &#125;


    间接递归
    a() &#123;
        b();
    &#125;

    b() &#123;
        a();
    &#125;

递归的步骤：
    1、递归的出口 -- 递归要结束
    2、递归的规则 -- 这个方法做什么

 递归的注意事项：
    1、构造方法不能递归
    2、递归要有出口，否则会内存溢出
    Arrays类             【重点】
    public static String toString(int[] a)    返回指定数组的内容的字符串表示形式
    public static void sort(int[] a)      按照数字顺序排列指定的数组
    public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA中时间日期类&amp;&amp;JAVA异常抛出</title>
    <url>/2021/10/13/Article6/</url>
    <content><![CDATA[<p>今日内容<br>    时间日期类           【掌握】<br>    异常                 【掌握】</p>
<p>时间日期类           【掌握】<br>    时间日期概述<br>        中国是位于东八区，有时差<br>        常见时间单位的换算<br>            1天 = 24小时<br>            1小时 = 60分<br>            1分 = 60秒<br>            1秒 = 1000毫秒         <em>**</em><br>            1毫秒 = 1000微妙</p>
<pre><code>    时间原点（基准时间）
        1970年1月1日 0时0分0秒

JDK8以前
    Date类
        Date类概述
            JDK给我们提供两个同名的Date类，但是它们绝对是位于不同的包，
            一个是位于java.util包下，一个是位于java.sql包下，今天我们使用的
            是java.util包下的这个Date类，使用的时候不要导错包

            Date类可以封装时间，封装的时间非常精确可以精确到毫秒值
            封装的时间可以是任意的时间，可以表示过去、现在和未来

            Date类最初功能的非常强大和完整，但是有弊端（不易国际化），JDK1.1开始就对Date类做了调整
            将两类功能抽取出来，Date类中的这两类功能就过时了，不推荐使用，将抽取出来的这两个功能分别
            放到Calendar类和SimpleDateFormat类中

        构造方法
            Date() ：表示的是现在（当前系统时间）
                    当前系统时间：就是程序运行所在的电脑的时间
            Date(long date) ：表示的是 时间原点+毫秒值 所落到的时间
                * long date参数表示的意思是毫秒值

        常用成员方法
             long getTime()：获取毫秒值
             void setTime(long time) ：设置毫秒值，也是在时间原点的基础上+毫秒值落到哪个时间就是哪个时间

        class Date &#123;
            private long time;

            public Date() &#123;&#125;
            public Date(long time) &#123;
                this.time = time;
            &#125;

            public int getTime() &#123;
                return time;
            &#125;

            public void setTime(long time) &#123;
                this.time = time;
            &#125;
        &#125;


        // 获取当前时间的毫秒值
        System.out.println(System.currentTimeMillis());
        System.out.println(new Date().getTime());

    SimpleDateFormat类
        格式化和解析类


        构造方法
            SimpleDateFormat(String pattern)
            * String pattern 模式,用于指定时间的格式

                Thu Jan 01 08:00:01 CST 1970    这种格式中国人不习惯
                1970年1月1日 8时0分0秒          yyyy年MM月dd日 HH时mm分ss秒
                1970年1月1日 08:00:00           yyyy年MM月dd日 HH:mm:ss
                1970-1-1 08:00:00               yyyy-MM-dd HH:mm:ss
                1970/1/1 08:00:00                yyyy/MM/dd HH:mm:ss

                年       y
                月       M
                日       d
                时       H
                分       m
                秒       s


        常用成员方法
            格式化：是将Date对象按照指定的模式转换一个时间字符串，为了显示时间方便
                Date -&gt; String
                public final String format(Date date)

            解析：是将一个时间字符串按照指定的模式识别出来，然后转换为Date对象，为了操作时间方便
                String -&gt; Date
                public Date parse(String source)



    Calendar类
        日历类，可以单独的操作（获取、修改、增减等）年、月、日、时、分、秒
        是一个抽象类


        以后在使用一个抽象类的时候，有两种方式：
            1、使用其子类创建对象   DateFormat/SimpleDateFormat
            2、看看抽象类中有没有静态方法，该静态方法可以返回该抽象类的子类对象  Calendar/GregorianCalendar

        获取对象
            static Calendar getInstance()：获取的日历对象默认时间是当前时间

        成员方法
            获取
                 int get(int field)
                    * int field 参数 传递是一个标记，你要告诉我获取的是年、月还是日等等

            修改
                 void set(int field, int value)
                          将给定的日历字段设置为给定值。

                 void set(int year, int month, int date)
                          设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值。
                 void set(int year, int month, int date, int hourOfDay, int minute)
                          设置日历字段 YEAR、MONTH、DAY_OF_MONTH、HOUR_OF_DAY 和 MINUTE 的值。
                 void set(int year, int month, int date, int hourOfDay, int minute, int second)
                          设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、MINUTE 和 SECOND 的值。

            增减
                void add(int field, int amount)

            转换（Date和Calendar的互转）
                 void setTime(Date date):将Calendar对象中的时间设置为和参数Date对象一样的时间
                 Date getTime()：将Calendar对象中的时间获取出来设置到Date对象中


JDK8以及之后
    LocalDateTime类   年月日+时分秒        【为主进行学习】
    LocalDate类       年月日
    LocalTime类       时分秒
    DateTimeFormatter类                  【格式化类，指定格式化和解析的模式】

    Period类
    Duration类

    ChronoUnit类           【了解】
    ChronoField类            【了解】


    LocalDateTime类
        获取LocalDateTime对象
            static LocalDateTime now()：获取的对象表示的时间是当前时间
            static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)


        格式化和解析（类似于SimpleDateFormat类的功能）
                String format(DateTimeFormatter formatter)
                    * DateTimeFormatter用于指定格式化和解析的模式
                static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)
                    * CharSequence text参数传递的就是要解析的时间字符串
                    * DateTimeFormatter用于指定格式化和解析的模式


        单独操作年月日时分秒（类似于Calendar类的功能）
            获取
                public int getYear() 获取年
                public int getMonthValue() 获取月份（1-12）
                public int getDayOfMonth() 获取月份中的第几天（1-31）
                public int getDayOfYear() 获取一年中的第几天（1-366）
                public DayOfWeek getDayOfWeek() 获取星期
                public int getMinute() 获取分钟
                public int getHour() 获取小时
            修改
                public LocalDateTime withYear(int year) 直接修改年
                public LocalDateTime withMonth(int month) 直接修改月
                public LocalDateTime withDayOfMonth(int dayofmonth) 直接修改日期(一个月中的第几天)
                public LocalDateTime withDayOfYear(int dayOfYear) 直接修改日期(一年中的第几天)
                public LocalDateTime withHour(int hour) 直接修改小时
                public LocalDateTime withMinute(int minute) 直接修改分钟
                public LocalDateTime withSecond(int second) 直接修改秒
            增减
                public LocalDateTime plusYears (long years) 添加或者减去年
                public LocalDateTime plusMonths(long months) 添加或者减去月
                public LocalDateTime plusDays(long days) 添加或者减去日
                public LocalDateTime plusHours(long hours) 添加或者减去时
                public LocalDateTime plusMinutes(long minutes) 添加或者减去分
                public LocalDateTime plusSeconds(long seconds) 添加或者减去秒
                public LocalDateTime plusWeeks(long weeks) 添加或者减去周

                public LocalDateTime minusYears (long years) 减去或者添加年
                public LocalDateTime minusMonths(long months) 减去或者添加月
                public LocalDateTime minusDays(long days) 减去或者添加日
                public LocalDateTime minusHours(long hours) 减去或者添加时
                public LocalDateTime minusMinutes(long minutes) 减去或者添加分
                public LocalDateTime minusSeconds(long seconds) 减去或者添加秒
                public LocalDateTime minusWeeks(long weeks) 减去或者添加周
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA中异常处理</title>
    <url>/2021/10/13/Article7/</url>
    <content><![CDATA[<p>异常                  【掌握】<br>    异常的概述<br>        什么是异常<br>            就是程序的运行的过程中，出现的不正常情况。</p>
<pre><code>    异常的继承体系结构
        java是面向对象的语言，在java中要研究任何的东西都必须先封装成对象，对象一定会有对应的类。
        异常也是一样的，封装了对象之后就可以更加方便的研究和处理异常，异常有很多，那么对应的异常类
        也会有很多。这些异常类的共性不断向上抽取，就形成了异常的继承体系结构。

        Throwable
            |-Error：严重的错误，无法通过异常处理语句进行处理的，这里的问题有些是硬件的问题、或者是需要修改代码逻辑才能解决的问题
            |-Exception：非严重的错误，可以通过异常处理语句进行处理的
                |-编译时异常
                |-运行时异常

        注意：
            1、我们要研究的是Exception子体系
            2、异常类非常多，但是这些异常类不需要单独一个个去学习，因为他们的区别只是一个名字的区别
               异常根据名字做到区分，取名是遵循见名知义的原则，见到类名就知道这是什么异常。


    异常的分类
        编译时异常：
            Exception下除了RuntimeException及其子类之外的都是属于编译时异常
            编译时异常在编译时期就会报出，如果没有处理编译就会报错
        运行时异常：
            RuntimeException及其子类
            运行时异常在编译时期不会报出，编译时期不处理不会报错

    JVM默认处理异常的方式
        1、在异常发生处停止程序的运行
        2、将发生的异常信息以红色字体的方式打印在控制台


    异常处理语句
        方式一:声明抛出处理 throws
            // 在方法的声明处，使用throws关键字将异常类名进行抛出的处理方式
            修饰符 返回值类型 方法名(参数列表) throws 异常类名 &#123;
                方法体;
            &#125;

            throws这种处理方式一般是对编译时异常进行处理，一般不会对运行时异常进行处理，因为没有意义

            throws抛出处理的方式并不是正在的在处理问题，而是一种踢皮球的方式，将自己的问题踢给别人，
            从而达到自己没有问题，但是别人接收到了这个问题，别人还是要处理。
            throws真正能处理只是程序的编译报错问题

        方式二：捕获处理  try...catch
            格式一
                try&#123;

                &#125;catch(异常类名 变量名) &#123;

                &#125;

            格式二
                try&#123;

                &#125;catch(异常类名 变量名) &#123;

                &#125;finally &#123;

                &#125;

            格式三
                try&#123;

                &#125;finally &#123;

                &#125;


            格式的注意事项：
                1、只有以上三种格式组合
                2、try和finally语句只能有一个，catch语句可以有多个
                3、try:检测、尝试
                       一般存放的是可能会出现异常的代码，进行检测看到底有没有异常
                   catch：捕获
                        如果在try中检测到出现了异常，则会通过catch进行捕获并处理
                        catch小括号是用于捕获的
                        catch大括号是用于处理的
                   finally：最终
                        它表示一定会执行的语句，最终不管是否出现异常都一定会执行的语句
                        比如：一些资源的释放代码这类收尾性的代码


            总结：
                throws一般用于处理编译时异常，处理编译报错，但是没有真正处理调用异常，一般不处理运行时异常
                try...catch既可以处理编译时异常，也可以处理运行时异常，是一种真正处理异常的方式

    throw和throws的区别
        throw：它不是处理异常的方式之一，你可以将它理解为制造异常并抛出给使用者，告诉使用者要处理这个问题
                throw使用在方法中，throw后面跟的是异常对象（名），后面跟的对象只能有一个
                NullPointerException e = new NullPointerException();
                throw e;// 异常对象名

                throw new NullPointerException();// 异常对象

        throws：是异常处理的方式之一，抛出处理异常
                throws使用在方法声明上，throws后面跟的是异常类名，后面跟的异常类名可以是多个



自定义异常                           【了解】
    什么是自定义异常
        就是我们不使用JDK提供的那些异常（类），而是自己定义异常类

    为什么要自定义异常
        为了做到见名知义
        其实JDK提供的异常我们也都能使用，只不过我们希望做到，看到异常类的名字就能反映
        这个异常出现了什么问题。

    如何自定义异常
        1、创建一个类继承Exception或者RuntimeException
            * 如果想自定义一个编译时异常，就继承Exception
            * 如果想自定义一个运行时异常，就继承RuntimeException
        2、生成一些构造方法，我们就给两个即可：一个空参，一个带字符串参数的构造（可以传递异常出现的原因）

    自定义的异常如何使用
        和JDK提供的这些异常一样使用
</code></pre><p>Collection-List       【掌握】<br>    常用集合类的体系结构<br>        单列集合<br>        Collection<br>            |-List：存取有序，有索引，可以存储重复元素的<br>                |-ArrayList：底层使用的是数组结构<br>                |-LinkedList：底层使用的是双向链表结构<br>                |-Vector<br>            |-Set：不保证存取有序，无索引，不能存储重复元素<br>                |-HashSet<br>                |-TreeSet</p>
<pre><code>    双列集合
    Map
        |-HashMap
        |-TreeMap

    学习体系结构的时候都应该从上往下学，最上面的类（接口）定义了最多的共性

Collection接口
    成员方法
        boolean add(E e) 添加元素

        boolean remove(Object o) 从集合中移除指定的元素
        boolean removeIf(Object o) 根据条件进行移除
        void clear() 清空集合中的元素

        boolean contains(Object o) 判断集合中是否存在指定的元素
        boolean isEmpty() 判断集合是否为空

        int size() 集合的长度，也就是集合中元素的个数

        Iterator&lt;E&gt; iterator()  集合的遍历方法

             // 获取到迭代器
             Iterator&lt;String&gt; it = coll.iterator();

             while(it.hasNext()) &#123;
                String s = it.next();
             &#125;


        Collection中没有任何一个和索引相关的方法。
        以下属于Collection接口中的方法的是（C）
            A、remove(int index)
            B、set(int index,E e)
            C、add(E e)
            D、add(int index,E e)
迭代器(Iterator)
    就是一个遍历集合的工具。

    成员方法
        boolean hasNext()：判断集合中是否还有下一个元素，如果有就返回true，否则返回false
        E next()  ：获取下一个元素，并将光标往下移动一位
        void remove() :在迭代器遍历的时候支持删除操作


增强for
    for(元素数据类型 变量名:单列集合或者数组)&#123;
        // 变量名中记录的就是集合中的每一个元素

    &#125;

    快捷键：iter + 回车
集合的遍历方式
    1、普通for循环，使用get(int index)和size()方法             【只能适用于List子体系下的集合】
        for (int i = 0; i &lt; list.size(); i++) &#123;
            String s = list.get(i);
            System.out.println(s);
        &#125;

    2、迭代器                                                 【适用于所有的单列集合】
        Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext()) &#123;
            String s = it.next();
            System.out.println(s);
        &#125;


    3、增强for                                                 【适用于所有的单列集合】
        for(String s:list)&#123;
            System.out.println(s);
        &#125;
</code></pre><p>List子体系<br>    List是Collection的子接口，所以Collection中的所有的方法List中都有（共性），<br>    除此之外，List中还有自己特有的方法</p>
<pre><code>特点：
    存取有序
    有索引
    可以存储重复元素的

特有方法（都是和索引相关的方法）
    void add(int index,E element) 在此集合中的指定位置插入指定的元素
    E remove(int index) 删除指定索引处的元素，返回被删除的元素
    E set(int index,E element) 修改指定索引处的元素，返回被修改的元素
    E get(int index) 返回指定索引处的元素



数据结构
    栈：先进后出，后进先出（LIFO） last in first out
    队列：先进先出，后进后出
    数组：查询修改快，增删慢
    链表：查询修改慢，增删快

    红黑树
    哈希表



节点（Node）
    记录上一个节点的地址
    数据值
    记录下一个节点的地址
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA泛型与数据结构</title>
    <url>/2021/10/13/Article8/</url>
    <content><![CDATA[<p>泛型                      【了解】<br>    什么是泛型<br>        JDK5.0的新特性（增强for、自动拆装箱、泛型）<br>        泛型是一种未知的(x)广泛的类型，可以表示任意的引用类型，你想让它是什么类型就可以是什么类型。<br>        <E>     E -&gt; String <String><br>        <E>     E -&gt; Integer <Integer></p>
<pre><code>    * 泛型中传递的数据类型只能是引用数据类型

泛型的好处
    是编译时期的类型检查的安全机制
    泛型只在编译时期有效，编译之后泛型就没有了（泛型的擦除）

    1、可以将可能出现的问题提前解决
        运行时期可能会有类型转换异常
        提前到了编译时期

    2、省去了强转的麻烦，简化代码块


    以后我们在使用集合的时候都需要加上泛型


自定义泛型类
    格式
        public class 类名&lt;泛型变量&gt; &#123;

        &#125;

        泛型变量：一般习惯上使用英文大写
                可以一个字母组成，也可以是多个字母组成     &lt;E&gt; &lt;T&gt; &lt;M&gt;  &lt;HELLO&gt; &lt;TYPE&gt; &lt;WORLD&gt;
                可以使用一个变量，也可以使用多个变量       &lt;K,V&gt;


    泛型变量的使用
        在类中只要是可以使用数据类型的地方都可以使用泛型变量
        可以使用在成员变量上
            当做数据类型使用
        可以使用在成员方法上
            当做参数类型
            返回值类型
            在方法体内部当做类型

    什么时候确定泛型类的实际类型
        在创建对象的时候确定实际类型

自定义泛型方法
    格式
        修饰符 &lt;泛型变量&gt; 返回值类型 方法名(参数列表) &#123;

        &#125;

    泛型变量的使用
        只能在方法上以及方法内使用泛型变量，只要是用到数据类型的地方都可以使用泛型变量
        当做参数类型
        返回值类型
        在方法体内部当做类型

    什么时候确定泛型方法的实际类型
        在调用方法的时候确定实际类型

自定义泛型接口
    格式
        public interface 接口名&lt;泛型变量&gt; &#123;

        &#125;

        泛型变量：一般习惯上使用英文大写
                可以一个字母组成，也可以是多个字母组成     &lt;E&gt; &lt;T&gt; &lt;M&gt;  &lt;HELLO&gt; &lt;TYPE&gt; &lt;WORLD&gt;
                可以使用一个变量，也可以使用多个变量       &lt;K,V&gt;


    泛型变量的使用
        在接口中只要是可以使用数据类型的地方都可以使用泛型变量
        可以使用在方法(抽象方法或者非抽象方法)上
            当做参数类型
            返回值类型
            在方法体内部当做类型

        常量的类型不能使用泛型变量替代，接口中的常量是static修饰。


    什么时候确定泛型类的实际类型
        在创建实现类对象的时候确定实际类型
            public class GenericityImpl1&lt;E&gt; implements Genericity&lt;E&gt;&#123;&#125;
            GenericityImpl1&lt;String&gt; genericity = new GenericityImpl1&lt;&gt;();

        一个类在实现接口的时候确定实际类型
            public class GenericityImpl2 implements  Genericity&lt;Integer&gt; &#123;
            &#125;

        一个接口在继承该接口的时候确定实际类型
            interface A extends Genericity&lt;String&gt; &#123;&#125;
           ...

泛型通配符
    &lt;?&gt;

    &lt;? extends E&gt;：上限限定，只能指定类型或者其子类
    &lt;? super E&gt;：下限限定，只能是指定类型或者其父类
</code></pre><p>Set集合<br>    特点：<br>        不保证存取有序<br>        无索引<br>        不能存储重复元素</p>
<pre><code>TreeSet               【了解】
    自然排序
        让集合元素对象所在的类实现Comparable接口，重写compareTo方法

        排序的规则就定义在compareTo方法中：
            1、方法的返回值,返回int类型的值，取值
                正数：存放的在右边（后面、下面）
                0：不存，去除掉
                负数：存放在左边（前面、上面）


            2、方法中的两个对象 this o
                this：当前要存储的元素
                o：已经存储到集合中的元素

                this - o 升序
                o - this 降序



    比较器排序
        让TreeSet容器具有排序的规则，将一个Comparator接口的实现类当做TreeSet的构造方法参数
        传递到TreeSet中
        TreeSet(Comparator&lt;? super E&gt; comparator)

        Comparator接口，重写compare方法

        排序的规则就定义在compare方法中：
            1、方法的返回值,返回int类型的值，取值
                正数：存放的在右边（后面、下面）
                0：不存，去除掉
                负数：存放在左边（前面、上面）


            2、方法中的两个对象 o1 o2
                o1：当前要存储的元素
                o2：已经存储到集合中的元素

                o1 - o2 升序
                o2 - o1 降序

                int compare(T o1, T o2);

    不管使用哪种方式都可以让TreeSet进行排序，如果这两种方式一种都没有选择，那么TreeSet排序就会报错。
    如果是JDK提供的类（Integer、String）
        一般都默认实现了自然排序规则，我们不需要设置任何的规则也可以正常排序
        但是如果我们不想要默认的自然排序规则，这时就选择比较器排序规则，这时两种排序规则
        同时存在，比较器排序规则会覆盖自然排序规则

    如果是我们自定义的类
        两种方式随便选择一种，你熟悉哪种就使用哪种。
</code></pre>]]></content>
  </entry>
  <entry>
    <title>JAVA HashSet</title>
    <url>/2021/10/13/Article9/</url>
    <content><![CDATA[<p>HashSet     【重点】<br>    哈希值<br>       因为hashCode方法是可以重写的，所以：<br>        同一个对象的哈希值一定相同<br>        不同对象的哈希值一般不同，但也有可能相同</p>
<pre><code>    哈希值不同的绝对不是同一个对象
    哈希值相同的可能是同一个对象，也可能不是同一个对象


HashSet底层不存储重复元素（元素唯一）的原理
    hashCode方法和equals方法

    首先通过hashCode方法计算哈希值，计算元素在底层数组中存储的位置，如果该位置上没有元素（null），
    直接存储了，如果该位置上有元素，则需要通过equals做进一步的比较，如果结果为true，则说明是同一个对象
    则不存储，如果结果为false，则存储。
</code></pre>]]></content>
  </entry>
  <entry>
    <title>LAMP 安装wordpress</title>
    <url>/2022/04/19/LNMPA+wordpress-01/</url>
    <content><![CDATA[<h3 id="LAMP-安装wordpress"><a href="#LAMP-安装wordpress" class="headerlink" title="LAMP 安装wordpress"></a>LAMP 安装wordpress</h3><p><strong>安装要求:</strong></p>
<p>•   CentOS/RHEL/Fedora/Debian/Ubuntu/Raspbian/Deepin/Aliyun/Amazon/Mint Linux发行版</p>
<p>•   需要5GB以上可用空间，MySQL 5.7,MariaDB 10至少9GB剩余空间,MySQL8.0最新版至少25GB以上</p>
<p>•   需要128MB以上内存(128MB小内存VPS,Xen需有SWAP,OpenVZ至少要有128MB以上的vSWAP或突发内存)，注意小内存请勿使用64位系统！</p>
<p>•   安装MySQL 5.6或5.7及MariaDB 10必须1G以上内存，更高版本至少要2G内存!。</p>
<p>•   安装PHP 7及以上版本必须1G以上内存!。</p>
<p>•   VPS或服务器必须设置好可用的yum或apt-get源并确保能正常工作，离线安装需要增加 CheckMirror=n 参数！</p>
<p>•   Linux下区分大小写，输入命令时请注意！</p>
<p>•   如有通过yum或apt-get安装的MySQL/MariaDB请自行备份数据等相关文件！</p>
<p>•   CentOS 5、6、8,Debian 6、7、8或更低版本官网已经结束支持无法直接使用，需自行更换vault或archive源！</p>
<p>•   CentOS 6、8请用lnmp 1.9+版本进行安装！</p>
<p>•   Ubuntu 18+,Debian 9+,Mint 19+,Deepin 15.7+及所有新的Linux发行版只能使用1.7+进行安装！</p>
<p>•   PHP 7.1.*以下版本不支持Ubuntu 19+、Debian 10等等非常新的Linux发行版！</p>
<p>•   阿里云Ubuntu 14.04系统模版有问题不要用！！！</p>
<p>•   PHP 7.4升级或安装必须CentOS 7+,Debian 8+,Ubuntu 16.04+且必须使用1.7+！！！</p>
<p>•   MySQL 8.0.23以下版本升级或安装必须CentOS 8+,Debian 9+,Ubuntu 16.04+且必须使用1.7+！！！</p>
<p>•   MySQL 8.0.24以上版本升级或安装必须Debian 11+,Ubuntu 20.04+,Fedora 33+且必须使用1.8！！！</p>
<p>安装步骤:</p>
<p>1、 使用XShell或类似的SSH工具登陆VPS或服务器；</p>
<p>2、 下载并安装LNMPA一键安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.8.tar.gz -cO lnmp1.8.tar.gz &amp;&amp; tar zxf lnmp1.8.tar.gz &amp;&amp; cd lnmp1.8 &amp;&amp; ./install.sh lnmpa</span><br></pre></td></tr></table></figure>
<p>PS:该命令一键安装了php+db+nginx+apache</p>
<p> 安装版本根据自行需求 如无特殊要求默认回车即可</p>
<p>如提示wget: command not found ，使用yum install wget 或 apt-get install wget 命安装。</p>
<p>3、 安装成功后进行修改配置文件来进行部署wordpress。</p>
<p>4、 先在root根目录进行下载wordpress主体文件 cd ~/ &amp;&amp; wget <a href="https://cn.wordpress.org/latest-zh_CN.tar.gz">https://cn.wordpress.org/latest-zh_CN.tar.gz</a></p>
<p>5、 Nginx与apache的配置文件不同 这里仅介绍apache如何配置 nginx仅需修改conf文件来进行域名绑定以及www根目录修改即可</p>
<p>6、 安装php扩展<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install php php-mysql php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel</span><br></pre></td></tr></table></figure><br>7、 查看php扩展安装是否成功php -v</p>
<p>8、 解压wordpress的tar.gz文件内容 tar zxf latest-zh_CN.tar.gz</p>
<p>9、 移动文件到httpd的启动目录<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv wordpress/ / home/wwwroot/</span><br></pre></td></tr></table></figure></p>
<p>10、   检查httpd配置文件是否监听80端口vim /usr/local/apache/conf/httpd.conf</p>
<p>修改配置文件为</p>
<p>Listen 80   这是监听端口</p>
<p>ServerName xiaoze.buzz:80           服务器名称 也就是域名</p>
<p>DocumentRoot “/home/wwwroot/ wordpress “       httpd启动的根目录</p>
<p>11、   重启httpd服务 systemctl restart httpd</p>
<p>12、   配置mysql</p>
<p>登录账户<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create DATABASE wordpress; ¬</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;¬</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit¬;</span></span><br></pre></td></tr></table></figure><br>13、   浏览器访问域名进行wordpress基础配置即可 以下不多做描述。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI/RM（开放系统互连参考模型）</title>
    <url>/2023/01/10/OSI-RM/</url>
    <content><![CDATA[<h3 id="OSI-RM（开放系统互连参考模型）"><a href="#OSI-RM（开放系统互连参考模型）" class="headerlink" title="OSI/RM（开放系统互连参考模型）"></a>OSI/RM（开放系统互连参考模型）</h3><h2 id="一：网络协议的概念"><a href="#一：网络协议的概念" class="headerlink" title="一：网络协议的概念"></a>一：网络协议的概念</h2><p><strong>网络协议</strong>：计算机网络和分布系统中互相通信的对等实体之间交换信息时必须遵守的规则的集合</p>
<p><strong>网络体系结构：</strong></p>
<p>指通信系统的整体设计方法，是计算机之间相互通信的层次，以及各层中的协议和 层次之间接口的集合，它为网络硬件、软件、协议，存取控制和网络拓扑提供标准。</p>
<p><strong>SNA</strong>：IBM公司独立开发的适合于自己公司的网络体系结构，System Network Architecture</p>
<p><strong>DNF</strong>：DEC公司独立开发的适合于自己公司的网络体系结构，Date NetWork Architecture</p>
<p><strong>OSI/RM</strong>：由ISO（国际标准化组织）统一规定的互联网参考模型Open Standard Interconnection /Reference Model（开放系统互连参考模型）</p>
<p><strong>任何两个遵守协议的标准的系统都可以互联通信</strong></p>
<p><strong>应用层：</strong></p>
<p>所有能产生网络流量的程序</p>
<p>提供应用程序运行的环境、负责管理和执行应用程序</p>
<p><strong>表示层：</strong></p>
<p>为数据在传输之前对加密、解密、压缩、解压缩及终端数据格式转换提供一套规则和约定</p>
<p><strong>会话层：</strong></p>
<p>考虑一个问题？我给我朋友发送邮件的时候它一定会接收吗？</p>
<p>一定能发送过去吗？</p>
<p>这一层是对对话的双方进行资格审查和验证的规则（发送时进行加密的规则，MD5加密），同时规定发送时的双工模式</p>
<p><strong>单工数据传输</strong>只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，举例：<strong>电视，广播。</strong></p>
<p><strong>半双工数据传输</strong>允许数据在两个方向上传输,但是,在某一时刻,只允许数据在一个方向上传输,它实际上是一种切换方向的单工通信；在同一时间只可以有一方接受或发送信息，可以实现双向通信。举例：<strong>对讲机</strong>。</p>
<p><strong>全双工数据通信</strong>允许数据同时在两个方向上传输,因此,全双工通信是两个单工通信方式的结合,它要求发送设备和接收设备都有独立的接收和发送能力；在同一时间可以同时接受和发送信息，实现双向通信，举例：<strong>电话通信。</strong></p>
<p><strong>传输层：</strong></p>
<p>设计本层的两个主要目的：</p>
<p>1、传输层可以提供在不同系统之间的进程间数据交互的可靠服务，在网络内两个实体之间建立端到端的通信信道（socket）（信息传输的通道），用来传输消息及报文分组，本层提供两端点可靠、透明的数据传输。</p>
<p>设备A给设备B发送信息，设备B怎么知道发送的是什么呢？？</p>
<p>答：通过端口与端口之间进行交互</p>
<p>2、可以为会话层提供与网络类型无关的可靠信息传输机制，对会话层遮蔽了下层网络操作的细节</p>
<p><strong>传输层是7层中最重要的一层，处在资源子网和通信子网之间。</strong></p>
<p><strong>网络层：</strong></p>
<p>负责建立、保持和终止通过中间设备的连接，同时负责通信子网内路径选择和拥挤控制。</p>
<p><strong>数据链路层：</strong></p>
<p>主要功能有如何将数据组装成块（帧），帧是本层的传输单位，如何处理数据在传输过程中出现的差错，如何调节发送速率使之与接收方匹配，在两个网络实体之间提供数据链路的建立、维持和释放管理</p>
<p><strong>数据成帧，MAC地址</strong></p>
<p><strong>物理层：</strong></p>
<p>物理层包括设备之间物理连接的接口和用户设备与网络终端设备之间的传输规则</p>
<p><strong>有四个重要的特性：</strong></p>
<p>机械特性：规定了物理连接时对插头和插座的几何尺寸、插针或插孔芯数及排列方式</p>
<p>电气特性：规定了信号状态的电压、电流的识别，最大传输速率等</p>
<p>功能特性：规定了接口信号的来源、作用及其他信号之间的关系</p>
<p>过程特性：规定了使用交换电路进行数据交换的控制步骤，这些控制步骤应用便于比</p>
]]></content>
      <tags>
        <tag>网络工程师资料</tag>
      </tags>
  </entry>
  <entry>
    <title>GND、RX、TX ------------（详解）</title>
    <url>/2023/01/10/RXTX/</url>
    <content><![CDATA[<h3 id="GND、RX、TX-——————（详解）"><a href="#GND、RX、TX-——————（详解）" class="headerlink" title="GND、RX、TX ——————（详解）"></a>GND、RX、TX ——————（详解）</h3><ol>
<li>GND、RX、TX是串口通信中的信号线，分别代表：<br> GND（Ground）：地线，或0线，它是公共端，也是负极。</li>
</ol>
<p>RX：接收数据。</p>
<p>TX：发送数据。</p>
<p>这些是串行通信中常用的信号线，它们协同工作以实现设备之间的数据交换。</p>
<ol>
<li>实际使用<br>在串口通信中，GND（地线）是用于建立电平参考，保证信号的稳定传输。RX（接收数据）和TX（发送数据）则是用于数据的双向传输。</li>
</ol>
<p>具体来说：</p>
<p>RX（接收数据）：在接收数据时，这条线用于从外部设备接收数据。例如，如果你的计算机想从另一个设备接收数据，那么这个设备就会通过RX线将数据发送到计算机。</p>
<p>TX（发送数据）：在发送数据时，这条线用于将数据从你的设备发送到外部设备。例如，如果你想将数据从计算机发送到另一个设备，那么计算机就会通过TX线将数据发送出去。</p>
<p>这些信号线通常在串行通信协议（如RS-232、RS-485、I2C等）中使用，以实现设备间的通信。在物理连接上，这些信号线通常是分开走线的，以减少电磁干扰（EMI）的影响。</p>
<p>另外，“RX”和“TX”也常常被用来指代接收和发送数据的数据线，而在一些其他的上下文中，例如网络通信或硬件接口中，它们可能有不同的含义。</p>
<p>3.扩展<br>除了上述提到的GND、RX和TX，串口通信中还可能涉及到其他的信号线，例如：</p>
<p>RTS（Request To Send）：请求发送信号，用于控制发送数据的许可。当RTS为高电平时，表示设备请求发送数据；当RTS为低电平时，表示设备允许接收数据。</p>
<p>CTS（Clear To Send）：清除发送信号，用于控制发送数据的许可。当CTS为高电平时，表示设备允许发送数据；当CTS为低电平时，表示设备不允许发送数据。</p>
<p>DTR（Data Terminal Ready）：数据终端就绪信号，用于表示设备已经准备好接收数据。当DTR为高电平时，表示设备已经准备好接收数据；当DTR为低电平时，表示设备尚未准备好接收数据。</p>
<p>DSR（Data Set Ready）：数据设置就绪信号，用于表示设备已经准备好发送数据。当DSR为高电平时，表示设备已经准备好发送数据；当DSR为低电平时，表示设备尚未准备好发送数据。</p>
<p>这些信号线协同工作，实现设备之间的数据通信。在串口通信中，数据的传输速率、数据格式等参数通常需要协商一致，以保证通信的稳定性和可靠性。</p>
<p>此外，在串口通信中，还有一些其他的常见概念和知识点需要注意：</p>
<p>串口通信协议：串口通信需要遵循一定的协议和规范，例如RS-232、RS-485、I2C等。不同的协议有不同的数据格式、传输速率、信号电平等要求，需要根据具体的通信需求选择合适的协议。</p>
<p>数据格式：串口通信中的数据通常需要按照一定的格式进行封装和处理，例如起始符、数据、校验码、结束符等。接收端需要解析这些格式，提取出有用的数据信息。</p>
<p>传输速率：串口通信中的传输速率一般指波特率（baud rate），即每秒传输的位数。常见的波特率有9600、19200、38400等，需要根据具体的通信需求选择合适的波特率。</p>
<p>信号电平：串口通信中的信号电平一般指逻辑电平，即高低电平表示逻辑0和逻辑1。常见的逻辑电平有TTL（Transistor-Transistor Logic）、CMOS（Complementary Metal-Oxide Semiconductor）等，需要根据具体的通信需求选择合适的逻辑电平。</p>
<p>防雷防浪涌：串口通信中的信号线通常比较脆弱，容易受到雷电和浪涌的影响。为了保护设备，需要在串口通信中加入防雷防浪涌保护措施，如加入电阻、电容等元件进行滤波和保护。</p>
]]></content>
      <tags>
        <tag>网络工程师资料</tag>
      </tags>
  </entry>
  <entry>
    <title>annotation</title>
    <url>/2022/01/12/annotation/</url>
    <content><![CDATA[<h4 id="Autowired-注解"><a href="#Autowired-注解" class="headerlink" title="@Autowired 注解"></a>@Autowired 注解</h4><p><strong>AutowiredAnnotationBeanPostProcessor</strong>在处理依赖注入时，从bean工厂中去获取，首先是<strong>根据字段的类型</strong>去找符合条件的bean，若得到的bean有多个，则找出有@Primary注解修饰的bean，若都没有，则<strong>退化成@Resource</strong>注解的功能，即<strong>根据字段名</strong>去寻找bean，若都没有，则会<strong>抛出找到多个bean的异常</strong>。可以定位到org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject方法细看注入逻辑。</p>
<p><strong>总结</strong>:@Autowired注解 是现根据 byType自动注入寻找符合的bean，如果没有就使用byName去寻找对象，与@resource的注解功能一样，如果没找到 则抛出异常(?)</p>
<p>@Autowired是先按照类型去挑选候选的bean，然后根据qualifier在这些候选的bean中去挑选要注入的bean。</p>
<h4 id="Resource注解"><a href="#Resource注解" class="headerlink" title="@Resource注解"></a>@Resource注解</h4><p>根据byName 根据字段名进行查找注解，但 需要class后跟类型匹配才可以进行注入，<br>即：</p>
<ul>
<li><strong>只指定@Resource注解的type属性，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</strong></li>
<li><strong>既指定了@Resource的name属性又指定了type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</strong></li>
</ul>
<p>所以如果使用name属性，则使用byName的自动注入策略， 而使用type属性时，则使用byType自动注入策略。如果name和type两个属性都不指定，这时将通过反射机制使用byName自动注入策略。 默认按照byName进行装配，当xml文件中存在相同类型的bean会根据byType进行装配。</p>
<p>@Resource是先按照名称去挑选要注入bean，如果找不到则退化成按照类型去注入。</p>
<h4 id="Resource与-Autowired-相等交换"><a href="#Resource与-Autowired-相等交换" class="headerlink" title="@Resource与@Autowired 相等交换"></a>@Resource与@Autowired 相等交换</h4><p>@Autowired</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDao&quot;)</span>  <span class="comment">//进行在相同bean下提升最高优先级</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Resource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Reference-注解"><a href="#Reference-注解" class="headerlink" title="@Reference 注解"></a>@Reference 注解</h4><p>@Reference是dubbo注解，它注入的是分布式的远程服务对象，需要dubbo配置使用。在微服务中，工程项目会分成很多模块（Maven工程），每个模块相当于一个服务，一个服务调用另一个服务的功能需要使用@Reference注解。</p>
<p>dubbo内调用@Service 进行远程dubbo注册</p>
<p>//@Service将这个类提供的方法（服务）对外发布。将访问的地址 ip，端口，路径注册到注册中心中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Reference(url = &quot;dubbo://127.0.0.1:2181&quot;,validation = &quot;true&quot;,timeout = 50000)</span><br></pre></td></tr></table></figure>
<p>进行dubbo客户端地址指定</p>
<h4 id="spring-中常见注解如下"><a href="#spring-中常见注解如下" class="headerlink" title="spring 中常见注解如下"></a>spring 中常见注解如下</h4><h5 id="声明bean注解类型"><a href="#声明bean注解类型" class="headerlink" title="声明bean注解类型"></a>声明bean注解类型</h5><h6 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h6><p>当指定bean类型不为@Controller，@Services时候可以使用@Component来进行标注，可以把普通的pojo类型实列化到spring容器中，相当于xml里面的中的<bean id="" class="">，所以可以理解为 @Component细分为@Reposity，@Service，@Controller</p>
]]></content>
  </entry>
  <entry>
    <title>dubbo</title>
    <url>/2022/01/12/dubbo-0/</url>
    <content><![CDATA[<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>dubbo是一个轻量级的服务之前通过RPC(<strong>一种远程调用</strong>)协议通信的分布式服务框架</p>
<ul>
<li>RPC协议（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</li>
</ul>
<h4 id="dubbo-架构"><a href="#dubbo-架构" class="headerlink" title="dubbo 架构"></a>dubbo 架构</h4><p>节点角色说明：</p>
<ul>
<li><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4></li>
</ul>
<p>在pojo里面引用Serializable接口实现序列化</p>
<p>把java对象转换成二进制流叫做序列化，相反把二进制流转换成java对象为反序列化</p>
<p>常见的序列化转换格式</p>
<ul>
<li>json-&gt;java对象</li>
<li>xml-&gt;java对象</li>
<li>二进制-&gt;java对象(Serialzable)</li>
</ul>
<p>序列化的作用就是为了不同jvm之间共享实例对象的一种解决方案</p>
<p>由java提供此机制,效率之高</p>
<h4 id="dubbo高级属性"><a href="#dubbo高级属性" class="headerlink" title="dubbo高级属性"></a>dubbo高级属性</h4><p>负载均衡</p>
<p>作用是用于分配客户端的请求，进而防止服务提供者的负载过高，导致宕机</p>
<ul>
<li>@Service(weight=100)，设置服务器的权重，值越大则处理越多</li>
<li>@Reference(loadbalance = “random”)，设置负载均衡策略<ul>
<li>random 随机选一台</li>
<li>RoundRobin 按照权重</li>
<li>LeastActive 选择请求排队数量少的机器，进行处理</li>
<li>ConsistentHash 一致性 Hash</li>
</ul>
</li>
</ul>
<h1 id="什么是Zookeeper"><a href="#什么是Zookeeper" class="headerlink" title="什么是Zookeeper"></a>什么是Zookeeper</h1><h5 id="单机锁"><a href="#单机锁" class="headerlink" title="单机锁"></a>单机锁</h5><ul>
<li>在单机程序中，当存在多个线程可以同时改变某个变量（可变共享变量）时，为了保证线程安全(数据不能出现脏数据)就需要对变量或代码块做同步，使其在修改这种变量时能够串行执行消除并发修改变量。</li>
<li>对变量或者堆代码码块做同步本质上就是加锁。<strong>目的就是实现多个线程在一个时刻同一个代码块只能有一个线程可执行</strong></li>
</ul>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p><strong>分布式锁的作用：在整个系统提供一个全局、唯一的锁，在分布式系统中每个系统在进行相关操作的时候需要获取到该锁，才能执行相应操作。</strong></p>
<p>分布式锁的实现可以是 Redis、Zookeeper，相对来说生产环境如果使用分布式锁可以考虑使用Redis实现而非Zk。</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo 通过 Github Actions 实现持续集成</title>
    <url>/2022/05/14/githubactions/</url>
    <content><![CDATA[<h1 id="Hexo-通过-Github-Actions-实现持续集成"><a href="#Hexo-通过-Github-Actions-实现持续集成" class="headerlink" title="Hexo 通过 Github Actions 实现持续集成"></a>Hexo 通过 Github Actions 实现持续集成</h1><h6 id="利用Github-Actions-1-来实现博客的持续集成-CI-以及持续部署-CD-2-。"><a href="#利用Github-Actions-1-来实现博客的持续集成-CI-以及持续部署-CD-2-。" class="headerlink" title="利用Github Actions[1]来实现博客的持续集成(CI)以及持续部署(CD)[2]。"></a>利用Github Actions<a href="https://zhuanlan.zhihu.com/p/137867759#ref_1">[1]</a>来实现博客的持续集成(CI)以及持续部署(CD)<a href="https://zhuanlan.zhihu.com/p/137867759#ref_2">[2]</a>。</h6><p>一般部署好hexo博客后通过<code>hexo g</code> 将写好的Markdown文件转化为HTML文件然后再<code>hexo d</code>把生成的public文件推送到Github仓库中。</p>
<p><strong>但是</strong>，直接将生成的可以运行的实际代码（生产版）推送到 GitHub 仓库上，而不是博客源码（开发版），那这样便无法利用 GitHub 来对源码进行版本控制，也就不利于博客未来的维护、更新、开发，以及可能的开源开发。<a href="https://zhuanlan.zhihu.com/p/137867759#ref_3">[3]</a></p>
<p> <a href="https://www.netlify.com/">Netlify</a>、 <a href="https://travis-ci.org/">Travis CI</a> 、 <a href="https://github.com/marketplace%3Ftype%3Dactions">Github Actions</a></p>
<p>本次主要讲Github Actions 来进行hexo实现在线写作。</p>
<h2 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h2><p><a href="https://github.com/features/actions">GitHub Actions</a> 是 GitHub 于 2018 年 10 月<a href="https://github.blog/changelog/2018-10-16-github-actions-limited-beta/">推出</a>的持续集成服务。</p>
<p>它的工作原理即为：当我们提前设置好需要自动化执行的任务（<code>.github/workflows</code> 下的文件）后，GitHub Actions 会监控当前仓库的某一个操作（如：<code>push</code>），一旦有此操作，就自动化执行这些任务。</p>
<p>我们设置的任务即为 <code>Action</code> ，它存放在博客根目录的 <code>.github/workflows</code> 下，后缀为 <code>.yml</code>。一个 Action 相当于是一个工作流 workflow，一个工作流则可以有多个任务 (<code>job</code>)，而每个任务又能分成几个步骤(<code>step</code>)。任务、步骤会依次执行。</p>
<p>现在代入 Hexo。我们把源码提交到了仓库的一个分支上，GitHub Actions 监听到了该分支的提交操作(<code>push</code>)，便会开始执行我们在 <code>.github/workflows</code> 下放置的文件中的代码。我们需要 GitHub Actions 执行的任务即为我们在根目录下执行的命令（如<code>hexo g</code>）。</p>
<p>注意：GitHub Actions 并没有我们的操作环境，我们得给它设置亦或是通过有关命令安装配置所需的环境。通过后面给出的任务文件内容可看出。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们得获取 GH_TOKEN 。</p>
<p><a href="https://github.com/settings/tokens">Personal access tokens (github.com)</a></p>
<p>选择框全选即可。</p>
<h2 id="本地hexo文件上传github私有库"><a href="#本地hexo文件上传github私有库" class="headerlink" title="本地hexo文件上传github私有库"></a>本地hexo文件上传github私有库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:Mintneko/mintneko.git</span><br><span class="line">git config --global user.email &quot;pokgliu@foxmail.com&quot;</span><br><span class="line">git config --global user.name &quot;Mintneko&quot;</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;blog master&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>编写actions运行文件</p>
<p>/.github/workflows/deployment.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Blog</span> <span class="string">CI/CD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发条件：在 push 到 master 分支后触发</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">blog-cicd:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">blog</span> <span class="string">build</span> <span class="string">&amp;</span> <span class="string">deploy</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span> <span class="comment"># 使用最新的 Ubuntu 系统作为编译部署的环境</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">codes</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">node</span></span><br><span class="line">      <span class="comment"># 设置 node.js 环境</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="comment"># 设置包缓存目录，避免每次下载</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">~/.npm</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">hexo</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="comment"># 下载 hexo-cli 脚手架及相关安装包</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install -g hexo-cli</span></span><br><span class="line"><span class="string">        npm install</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">files</span></span><br><span class="line">      <span class="comment"># 编译 markdown 文件</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo generate</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span> <span class="string">blog</span></span><br><span class="line">      <span class="attr">env:</span> </span><br><span class="line">        <span class="comment"># Github 仓库</span></span><br><span class="line">        <span class="attr">GITHUB_REPO:</span> <span class="string">github.com/Mintneko/mintneko.github.io</span></span><br><span class="line">        <span class="comment"># Coding 仓库</span></span><br><span class="line">        <span class="comment">#CODING_REPO: e.coding.net/yifanzheng/blogs.git</span></span><br><span class="line">        <span class="comment"># Gitee 仓库</span></span><br><span class="line">        <span class="comment">#GITEE_REPO: gitee.com/yifanzheng/yifangzheng.gitee.io.git</span></span><br><span class="line">        <span class="comment">#两条编写在下方run里面</span></span><br><span class="line">        <span class="comment">#git push --force --quiet &quot;https://RoYFbFDSfM:$&#123;&#123; secrets.CODING_TOKEN &#125;&#125;@$CODING_REPO&quot; master:master</span></span><br><span class="line">        <span class="comment">#git push --force --quiet &quot;https://yifanzheng:$&#123;&#123; secrets.GITEE_ACCESS_TOKEN &#125;&#125;@$GITEE_REPO&quot; master:master</span></span><br><span class="line">      <span class="comment"># 将编译后的博客文件推送到指定仓库</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cd ./public &amp;&amp; git init &amp;&amp; git add .</span></span><br><span class="line"><span class="string">        git config user.name &quot;Mintneko&quot;</span></span><br><span class="line"><span class="string">        git config user.email &quot;pokgliu@foxmail.com&quot;</span></span><br><span class="line"><span class="string">        git add .</span></span><br><span class="line"><span class="string">        git commit -m &quot;GitHub Actions Auto Builder at $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span></span><br><span class="line"><span class="string">        git push --force --quiet &quot;https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$GITHUB_REPO&quot; master:master</span></span><br></pre></td></tr></table></figure>
<p>修改好名字和邮箱即可</p>
]]></content>
  </entry>
  <entry>
    <title>光纤跳线-接头类型</title>
    <url>/2024/01/29/guangxian/</url>
    <content><![CDATA[<p><img src="https://pic4.zhimg.com/80/v2-7630f65fb7f668840e87e038d222159f_720w.webp" alt="img"></p>
<p>（1）<strong>FC型光纤跳线</strong>：外部加强方式是采用金属套，紧固方式为螺丝扣。一般在ODF侧采用(配线架上用的最多)</p>
<p>（2）<strong>SC型光纤跳线</strong>：连接GBIC光模块的连接器，它的外壳呈矩形，紧固方式是采用插拔销闩式，不须旋转。(路由器交换机上用的最多)</p>
<p>（3）<strong>ST型光纤跳线</strong>：常用于光纤配线架，外壳呈圆形，紧固方式为螺丝扣。(对于10Base-F连接来说，连接器通常是ST类型。常用于光纤配线架)</p>
<p>（4）<strong>LC型光纤跳线</strong>：连接SFP模块的连接器，它采用操作方便的模块化插孔(RJ)闩锁机理制成。(路由器常用)</p>
<p>（5）<strong>MT-RJ型光纤跳线</strong>：收发一体的方形光纤连接器，一头双纤收发一体</p>
<p>ST、SC连接器接头常用于一般网络。ST头插入后旋转半周有一卡口固定，缺点是容易折断;SC连接头直接插拔，使用很方便，缺点是容易掉出来;FC连接头一般电信网络采用，有一螺帽拧到适配器上，优点是牢靠、防灰尘，缺点是安装时间稍长。MTRJ型光纤跳线由两个高精度塑胶成型的连接器和光缆组成。连接器外部件为精密塑胶件，包含推拉式插拔卡紧机构。适用于在电信和数据网络系统中的室内应用。</p>
<p>光纤模块：一般都支持热插拔，GBIC使用的光纤接口多为SC或ST型;SFP，即：小型封装GBIC，使用的光纤为LC型。</p>
]]></content>
  </entry>
  <entry>
    <title>ICMP类型字段(Type)以及代码字段(Code)含义汇总</title>
    <url>/2024/01/31/icmp-type-code/</url>
    <content><![CDATA[<h1 id="ICMP类型字段-Type-以及代码字段-Code-含义汇总"><a href="#ICMP类型字段-Type-以及代码字段-Code-含义汇总" class="headerlink" title="ICMP类型字段(Type)以及代码字段(Code)含义汇总"></a>ICMP类型字段(Type)以及代码字段(Code)含义汇总</h1><h4 id="ICMP报文可分为两大类：一、有关信息采集和配置的ICMP报文-称为查询（query）或者信息类报文-information-message-二、有关IP数据报传递的ICMP报文（称为差错报文（error-message））"><a href="#ICMP报文可分为两大类：一、有关信息采集和配置的ICMP报文-称为查询（query）或者信息类报文-information-message-二、有关IP数据报传递的ICMP报文（称为差错报文（error-message））" class="headerlink" title="ICMP报文可分为两大类：一、有关信息采集和配置的ICMP报文(称为查询（query）或者信息类报文(information message)),二、有关IP数据报传递的ICMP报文（称为差错报文（error message））."></a>ICMP报文可分为两大类：一、有关信息采集和配置的ICMP报文(称为查询（query）或者信息类报文(information message)),二、有关IP数据报传递的ICMP报文（称为差错报文（error message））.</h4><p>下图加粗的为常用报文类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型TYPE</th>
<th style="text-align:left">代码CODE</th>
<th style="text-align:left">用途\</th>
<th style="text-align:left">描述 Description</th>
<th style="text-align:left">查询类Query</th>
<th>差错类Error</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left"><strong>Echo Reply——回显应答（Ping应答）</strong></td>
<td style="text-align:left"><strong>x</strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Network Unreachable——网络不可达</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong></td>
<td style="text-align:left"><strong>1</strong></td>
<td style="text-align:left"><strong>Host Unreachable——主机不可达</strong></td>
<td style="text-align:left"><em>**</em></td>
<td style="text-align:left"><strong>x</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">Protocol Unreachable——协议不可达</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong></td>
<td style="text-align:left"><strong>3</strong></td>
<td style="text-align:left"><strong>Port Unreachable——端口不可达</strong></td>
<td style="text-align:left"><em>**</em></td>
<td style="text-align:left"><strong>x</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong></td>
<td style="text-align:left"><strong>4</strong></td>
<td style="text-align:left"><strong>Fragmentation needed but no frag. bit set——需要进行分片但设置不分片比特</strong></td>
<td style="text-align:left"><em>**</em></td>
<td style="text-align:left"><strong>x</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">5</td>
<td style="text-align:left">Source routing failed——源站选路失败</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">6</td>
<td style="text-align:left">Destination network unknown——目的网络未知</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
<td style="text-align:left">Destination host unknown——目的主机未知</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">8</td>
<td style="text-align:left">Source host isolated (obsolete)——源主机被隔离（作废不用）</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">9</td>
<td style="text-align:left">Destination network administratively prohibited——目的网络被强制禁止</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">10</td>
<td style="text-align:left">Destination host administratively prohibited——目的主机被强制禁止</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">11</td>
<td style="text-align:left">Network unreachable for TOS——由于服务类型TOS，网络不可达</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">12</td>
<td style="text-align:left">Host unreachable for TOS——由于服务类型TOS，主机不可达</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong></td>
<td style="text-align:left"><strong>13</strong></td>
<td style="text-align:left"><strong>Communication administratively prohibited by filtering——由于过滤，通信被强制禁止</strong></td>
<td style="text-align:left"><em>**</em></td>
<td style="text-align:left"><strong>x</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">14</td>
<td style="text-align:left">Host precedence violation——主机越权</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">15</td>
<td style="text-align:left">Precedence cutoff in effect——优先中止生效</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Source quench——源端被关闭（基本流控制）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Redirect for network——对网络重定向</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>1</strong></td>
<td style="text-align:left"><strong>Redirect for host——对主机重定向</strong></td>
<td style="text-align:left"><em>**</em></td>
<td style="text-align:left"><em>**</em></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2</td>
<td style="text-align:left">Redirect for TOS and network——对服务类型和网络重定向</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">3</td>
<td style="text-align:left">Redirect for TOS and host——对服务类型和主机重定向</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>8</strong></td>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left"><strong>Echo request——回显请求（Ping请求）</strong></td>
<td style="text-align:left"><strong>x</strong></td>
<td style="text-align:left"><em>**</em></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Router advertisement——路由器通告</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Route solicitation——路由器请求</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>11</strong></td>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left"><strong>TTL equals 0 during transit——传输期间生存时间为0</strong></td>
<td style="text-align:left"><em>**</em></td>
<td style="text-align:left"><strong>x</strong></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">1</td>
<td style="text-align:left">TTL equals 0 during reassembly——在数据报组装期间生存时间为0</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left"><strong>12</strong></td>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left"><strong>IP header bad (catchall error)——坏的IP首部（包括各种差错）</strong></td>
<td style="text-align:left"><em>**</em></td>
<td style="text-align:left"><strong>x</strong></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">1</td>
<td style="text-align:left">Required options missing——缺少必需的选项</td>
<td style="text-align:left"></td>
<td style="text-align:left">x</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Timestamp request (obsolete)——时间戳请求（作废不用）</td>
<td style="text-align:left">x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"></td>
<td style="text-align:left">Timestamp reply (obsolete)——时间戳应答（作废不用）</td>
<td style="text-align:left">x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Information request (obsolete)——信息请求（作废不用）</td>
<td style="text-align:left">x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Information reply (obsolete)——信息应答（作废不用）</td>
<td style="text-align:left">x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Address mask request——地址掩码请求</td>
<td style="text-align:left">x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Address mask reply——地址掩码应答</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>读取Excel的N中方式</title>
    <url>/2022/01/13/openExcel/</url>
    <content><![CDATA[<h4 id="读取Excel的N中方式"><a href="#读取Excel的N中方式" class="headerlink" title="读取Excel的N中方式"></a>读取Excel的N中方式</h4><ul>
<li><p>spring boot 继承EsayExcel 实现excel的文件上传下载</p>
<p>导入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">2.1</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>创建excel表实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadData</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置列对应的属性</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;学生编号&quot;,index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> Integer no;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;学生姓名&quot;,index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 上传execl文件，解析数据到数据库</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@ApiOperation(&quot;上传excel，解析excel接口&quot;)</span></span><br><span class="line"> <span class="meta">@PostMapping(&quot;uploadExcel&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> R <span class="title">uploadExcel</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">     eduSubjectService.uploadExcelFile(file);</span><br><span class="line">     <span class="keyword">return</span> R.ok();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>excel 读取数据的监听  主要是继承AnalysisEventListener<ReadData> 之后，重写invoke方法，然后在里面处理数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">ReadData</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    List&lt;ReadData&gt; list = <span class="keyword">new</span> ArrayList&lt;ReadData&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一行一行去读取excel内容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(ReadData readData, AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(readData);</span><br><span class="line">        list.add(readData);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 读取excel表头信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表头信息：&quot;</span>+headMap);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 读取完成后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件下载</p>
<p>创建excel实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteData</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置表头属性名称</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;学生编号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer no;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;学生姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试test写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcelWriteData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写法1</span></span><br><span class="line">        String fileName = <span class="string">&quot;D:\\excel\\11.xlsx&quot;</span>;</span><br><span class="line">        <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">        <span class="comment">// 如果这里想使用03 则 传入excelType参数即可</span></span><br><span class="line">        EasyExcel.write(fileName, WriteData.class).sheet(<span class="string">&quot;写入方法一&quot;</span>).doWrite(data());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环设置要添加的数据，最终封装到list集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;WriteData&gt; <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;WriteData&gt; list = <span class="keyword">new</span> ArrayList&lt;WriteData&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            WriteData data = <span class="keyword">new</span> WriteData();</span><br><span class="line">            data.setNo(i);</span><br><span class="line">            data.setName(<span class="string">&quot;张三&quot;</span>+i);</span><br><span class="line">            list.add(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>java POI上传excel的简单调用</p>
</li>
<li><p>Spring Boot+poi实现excel文件上传&amp;下载</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>opengauss 华为高斯数据库安装B-format 兼容mysql</title>
    <url>/2024/11/27/opengauss/</url>
    <content><![CDATA[<h2 id="opengauss-华为高斯数据库安装B-format-兼容mysql"><a href="#opengauss-华为高斯数据库安装B-format-兼容mysql" class="headerlink" title="opengauss 华为高斯数据库安装B-format 兼容mysql"></a>opengauss 华为高斯数据库安装B-format 兼容mysql</h2><p>opengauss是华为基于PostgreSQL魔改的数据库。本文介绍轻量版的安装。</p>
<p>安装包下载地址：<a href="https://opengauss.org/zh/download/">https://opengauss.org/zh/download/</a></p>
<h2 id="OpenGauss-5-x-安装"><a href="#OpenGauss-5-x-安装" class="headerlink" title="OpenGauss 5.x 安装"></a><strong>OpenGauss 5.x 安装</strong></h2><h3 id="1-设置SEMMNI"><a href="#1-设置SEMMNI" class="headerlink" title="1.设置SEMMNI"></a>1.设置SEMMNI</h3><p>如果不设置的话在安装过程中会报错 the maximum number of SEMMNI is not correct, the current SEMMNI is xxx. Please check it.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"><span class="comment">#增加如下语句在文件结尾后wq保存后</span></span><br><span class="line">kernel.sem = 250 32000 100 999</span><br><span class="line"><span class="comment">#保存后输入下方命令检查是否生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<h3 id="2-新建用户和用户组"><a href="#2-新建用户和用户组" class="headerlink" title="2.新建用户和用户组"></a>2.新建用户和用户组</h3><p>openGauss不能使用root用户<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新增组gaussdbuser</span></span><br><span class="line">groupadd gaussdbuser</span><br><span class="line"><span class="comment">#新增用户gaussdbuser</span></span><br><span class="line">useradd -g gaussdbuser gaussdbuser</span><br><span class="line"><span class="comment">#设置gaussdbuser用户密码</span></span><br><span class="line">passwd gaussdbuser</span><br></pre></td></tr></table></figure></p>
<h3 id="3-下载安装包解压"><a href="#3-下载安装包解压" class="headerlink" title="3.下载安装包解压"></a>3.下载安装包解压</h3><p>通过wget或者上传工具上传安装压缩包</p>
<p>注意：在这一步需要通过非root用户的方式去执行，建议是使用刚刚创建的gaussdbuser<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装上传工具 install lrzsz</span></span><br><span class="line"><span class="comment">#解压压缩包</span></span><br><span class="line">mkdir opengauss</span><br><span class="line">tar -zxvf  openGauss-Lite*</span><br><span class="line"><span class="built_in">cd</span> opengauss</span><br></pre></td></tr></table></figure></p>
<h3 id="4-安装数据库"><a href="#4-安装数据库" class="headerlink" title="4.安装数据库"></a>4.安装数据库</h3><p>将gaussdbuser@123修改为密码后进行安装启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> gaussdbuser@123 | sh ./install.sh --mode single -D openGauss/data -R openGauss/install --start</span><br></pre></td></tr></table></figure>
<p>最后的安装目录为/home/gaussdbuser/opengauss/openGauss/data/</p>
<h3 id="5-修改配置"><a href="#5-修改配置" class="headerlink" title="5.修改配置"></a>5.修改配置</h3><p>修改监听ip的配置和密码加密的方式，防止navicat无法连接。 </p>
<p>修改 standard_conforming_strings 转义符,防止插入转义符被识别为字符串.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim data/pg_hba.conf</span><br><span class="line"><span class="comment">#然后进行搜索下列关键字  附: trust一般用于本地连接不进行密码校验</span></span><br><span class="line"><span class="comment">#/host    all    搜索到这行 把&quot;127.0.0.1/32&quot;替换成&quot;0.0.0.0/0&quot; 和 把&quot;trust&quot;f替换成&quot;md5&quot;</span></span><br><span class="line">vim data/postgresql.conf</span><br><span class="line"><span class="comment">#搜索&quot;#listen_addresses&quot; 即/#listen_addresses 搜索后 将最前面的&quot;#&quot;去掉 和 将&quot;localhost&quot;替换成*</span></span><br><span class="line"><span class="comment">#搜索&quot;4&quot; 即/password_encryption_type  即将前面的#去掉 和将2修改成为0代表使用md5的加密方式</span></span><br><span class="line"><span class="comment">#搜索&quot;standard_conforming_strings&quot; 即/standard_conforming_strings  即将前面的#去掉 和将on修改成为off代表使用旧方式的转义符</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-重启服务"><a href="#6-重启服务" class="headerlink" title="6.重启服务"></a>6.重启服务</h3><p>注意启动需要gaussdbuser用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">install/bin/gs_ctl restart -D data/</span><br></pre></td></tr></table></figure>
<h2 id="数据库使用"><a href="#数据库使用" class="headerlink" title="数据库使用"></a>数据库使用</h2><h3 id="gsql命令和常用sql"><a href="#gsql命令和常用sql" class="headerlink" title="gsql命令和常用sql"></a>gsql命令和常用sql</h3><h3 id="1-使用gaussdbuser用户连接数据库-本地登陆无需输入密码："><a href="#1-使用gaussdbuser用户连接数据库-本地登陆无需输入密码：" class="headerlink" title="1.使用gaussdbuser用户连接数据库-本地登陆无需输入密码："></a>1.使用gaussdbuser用户连接数据库-本地登陆无需输入密码：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">install/bin/gsql -d postgres -p 5432 -r</span><br></pre></td></tr></table></figure>
<h3 id="2-查看用户信息"><a href="#2-查看用户信息" class="headerlink" title="2.查看用户信息"></a>2.查看用户信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\du</span><br></pre></td></tr></table></figure>
<h3 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3.删除数据库"></a>3.删除数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drop database opengauss;</span><br></pre></td></tr></table></figure>
<h3 id="4-创建用户"><a href="#4-创建用户" class="headerlink" title="4.创建用户"></a>4.创建用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create user opengauss createrole password <span class="string">&#x27;Opengauss@123&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-创建数据库-B模式即MySQL模式-一定要设置成B"><a href="#5-创建数据库-B模式即MySQL模式-一定要设置成B" class="headerlink" title="5.创建数据库 B模式即MySQL模式(一定要设置成B)"></a>5.创建数据库 B模式即MySQL模式(一定要设置成B)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE opengauss WITH dbcompatibility=<span class="string">&#x27;B&#x27;</span> OWNER=opengauss ENCODING=<span class="string">&#x27;UTF-8&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-切换到数据库"><a href="#6-切换到数据库" class="headerlink" title="6.切换到数据库"></a>6.切换到数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\c opengauss                   <span class="comment">#切换到opengauss数据库</span></span><br></pre></td></tr></table></figure>
<h3 id="7-创建SCHEMA，需切换到指定的数据库执行"><a href="#7-创建SCHEMA，需切换到指定的数据库执行" class="headerlink" title="7.创建SCHEMA，需切换到指定的数据库执行"></a>7.创建SCHEMA，需切换到指定的数据库执行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE SCHEMA <span class="string">&quot;opengauss&quot;</span> CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>
<h3 id="8-退出gsql"><a href="#8-退出gsql" class="headerlink" title="8.退出gsql"></a>8.退出gsql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>opengauss</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的三次握手各字段(ack,seq,ACK,SYN)</title>
    <url>/2023/01/31/tcp-ack-seq-syn/</url>
    <content><![CDATA[<h1 id="TCP的三次握手各字段-ack-seq-ACK-SYN"><a href="#TCP的三次握手各字段-ack-seq-ACK-SYN" class="headerlink" title="TCP的三次握手各字段(ack,seq,ACK,SYN)"></a>TCP的三次握手各字段(ack,seq,ACK,SYN)</h1><p>三次握手过程解释<br>三次交换数据的过程细节先不看，从客户端、服务器状态进行解释。</p>
<p>状态变化：</p>
<p>客户端和服务器同时属于closed状态，表示没有连接关系。<br>客户端发送请求，客户端打开发送(SYN-sent)状态，同时服务器打开监听(Listen)状态；<br>服务器在接收到客户端的请求时，服务器切换为回复(SYN-recvd)状态；<br>客户端在接收到服务器的响应时，客户端切换为稳定连接(Estab-lished)状态的同时发送第二次数据包。<br>服务器在接收到客户端的第二次数据时，服务器切换为稳定连接(Estab-lished)状态。<br>双方建立稳定连接后，开始正常通信数据。<br>重要字段<br>过程了解之后，就应该知道其传输的字段是什么意思了。如下是其中重要的字段。</p>
<p>序号(sequence number)：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
<p>确认号（acknowledgement number）：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p>
<p>标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p>
<p>URG：紧急指针（urgent pointer）有效。</p>
<p>ACK：确认序号有效。（为了与确认号ack区分开，我们用大写表示）</p>
<p>PSH：接收方应该尽快将这个报文交给应用层。</p>
<p>RST：重置连接。</p>
<p>SYN：发起一个新连接。</p>
<p>FIN：释放一个连接。</p>
<p>那么这些字段有什么作用呢？</p>
<p>seq序号、ack序号：用于确认数据是否准确，是否正常通信。</p>
<p>标志位：用于确认/更改连接状态。</p>
<p>下述为各标签的作用，根据标点符号相互的对应。</p>
<p>第一次握手：你能和我建立连接吗，可以接受到我的数据吗。</p>
<p> SYN = 1 ，seq = x</p>
<p>第二次握手：可以建立连接，我接受到你的请求了，能接受到我的数据吗，你的数据是这个吗</p>
<p> SYN = 1 ，ACK = 1 ，seq = y ，ack = x + 1</p>
<p>第三次握手：我已经收到你的回复，这是我的数据，这是你的数据（用于再次核对）</p>
<p> ACK = 1 ，seq = x + 1 ，ack = y + 1</p>
<p>建立连接成功。</p>
<p>总结<br>就这样，把标签解释的很简单了，这样在回头去看字段的正常解释，就很简单理解啦~</p>
<p>各字段在TCP三次握手中的作用：</p>
<p>SYN：用于建立连接。</p>
<p>ACK：用于确定收到了请求。</p>
<p>seq：发送自己的数据。</p>
<p>ack：发送接收到的对方的数据。</p>
]]></content>
  </entry>
  <entry>
    <title>VLAN操作模式</title>
    <url>/2024/01/31/vlan-mode/</url>
    <content><![CDATA[<h1 id="华三olt-配置UNI端口VLAN操作模式（VLAN透传模式、VLAN标记模式、VLAN-Translation模式VLAN-QinQ模式、VLAN-Trunk模式）"><a href="#华三olt-配置UNI端口VLAN操作模式（VLAN透传模式、VLAN标记模式、VLAN-Translation模式VLAN-QinQ模式、VLAN-Trunk模式）" class="headerlink" title="华三olt:配置UNI端口VLAN操作模式（VLAN透传模式、VLAN标记模式、VLAN Translation模式VLAN QinQ模式、VLAN Trunk模式）"></a>华三olt:配置UNI端口VLAN操作模式（VLAN透传模式、VLAN标记模式、VLAN Translation模式VLAN QinQ模式、VLAN Trunk模式）</h1><p>华三olt:配置UNI端口VLAN操作模式（VLAN透传模式、VLAN标记模式、VLAN Translation模式VLAN QinQ模式、VLAN Trunk模式）<br>\1. 功能简介<br>UNI端口VLAN操作模式包括：<br>·VLAN透传模式：适用于用户端的家庭网关或交换机由运营商提供并管理的情况。此时家庭网关或交换机添加的VLAN Tag可以信任，ONU对接收到的以太网帧进行透明转发。<br>·VLAN标记模式：适用于用户端的家庭网关或交换机添加的VLAN Tag不被信任的情况。其详细处理方式如表3-34所示。<br>·VLAN Translation模式：在VLAN Translation模式下，ONU将用户自行添加的VLAN Tag（可能在同一个EPON系统内有其他用户使用与其相同的VLAN）转换为唯一的网络侧VLAN Tag。VLAN Translation模式下ONU对数据报文的处理方式如表3-34所示。<br>·VLAN QinQ模式：在VLAN QinQ模式下，ONU为用户自行添加的VLAN Tag再加上一个网络层VLAN Tag，以实现运营商对进入到网络中的业务的VLAN进行统一的管理和控制。<br>VLAN QinQ模式下还可以配置透传功能，使端口在收到带有指定VLAN Tag的报文后，不为其添加外层VLAN Tag而直接在运营商网络中传输。例如，当某VLAN为企业专线VLAN或网管VLAN时，就可以使用VLAN透传功能。<br>VLAN QinQ模式下ONU对数据报文的处理方式以ONU实际型号和版本支持情况为准。<br>·VLAN Trunk模式：ONU的UNI端口能发送多个VLAN的报文，发出去的端口缺省VLAN的报文不带VLAN Tag，其他VLAN的报文都必须带VLAN Tag。通常用于网络传输设备之间的互连。其详细处理方式如表3-34所示。<br>VLAN N:1聚合模式：该模式下，ONU设备将上行的多个VLAN转换为唯一的网络侧VLAN Tag；并将下行报文的网络侧VLAN Tag反向转换为对应的多个VLAN。其详细处理方式如下表所示。<br>VLAN操作模式对应的数据包处理方式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口VLAN操作模式</th>
<th>方向</th>
<th>以太网帧是否带VLAN Tag</th>
<th>处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>VLAN透传模式</td>
<td>上行</td>
<td>带VLAN Tag</td>
<td>不处理Tag，直接转发报文</td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>下行</td>
<td>带VLAN Tag</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VLAN 标记模式</td>
<td>上行</td>
<td>带VLAN Tag</td>
<td>直接丢弃</td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>添加端口缺省VLAN的Tag后，再转发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>下行</td>
<td>带VLAN Tag</td>
<td>按照VLAN ID转发到相应的UNI端口，最后删除VLAN Tag</td>
<td></td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>直接丢弃</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VLAN Translation模式</td>
<td>上行</td>
<td>带VLAN Tag</td>
<td>·   当原有Tag的VLAN ID为端口缺省的VLAN ID时，则直接丢弃·   当原有Tag的VLAN ID在对应端口的VLAN Translation列表中有对应的表项时，将原有VLAN ID转换为表项中所对应的VLAN ID后再转发；否则直接丢弃</td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>添加端口缺省VLAN的Tag后，再转发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>下行</td>
<td>带VLAN Tag</td>
<td>·   当原有Tag的VLAN ID为端口缺省的VLAN ID时，则删除VLAN Tag后，再转发·   当原有Tag的VLAN ID在对应端口的VLAN Translation列表中有对应的表项时，将原有VLAN ID转换为表项中所对应的VLAN ID后再转发；否则直接丢弃</td>
<td></td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>直接丢弃</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VLAN Trunk模式</td>
<td>上行</td>
<td>带VLAN Tag</td>
<td>当报文的VLAN ID在端口允许通过的VLAN范围内时，直接转发；否则丢弃</td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>给报文添加端口PVID的Tag后转发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>下行</td>
<td>带VLAN Tag</td>
<td>·   当原有Tag的VLAN ID为端口的PVID时，ONU对报文的处理方式以ONU实际型号和版本支持情况为准·   当原有Tag的VLAN ID在端口允许通过的VLAN范围内时，直接转发；否则丢弃该报文</td>
<td></td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>直接丢弃</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VLAN N:1聚合模式</td>
<td>上行</td>
<td>带VLAN Tag</td>
<td>当原有Tag的VLAN ID在对应端口的VLAN Aggregation列表中有对应的表项时，将原有VLAN ID转换为表项中所对应的VLAN ID，并记录报文的源MAC地址，再转发；否则直接丢弃</td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>给报文添加端口PVID的Tag后转发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>下行</td>
<td>带VLAN Tag</td>
<td>·   当原有Tag的VLAN ID为端口的PVID时，则删除VLAN Tag后，再转发·   当原有Tag的VLAN ID在对应端口的VLAN Aggregation列表中有对应的表项时，根据MAC地址值将原有VLAN ID转换为表项中所对应的VLAN ID，再转发；否则丢弃该报文</td>
<td></td>
</tr>
<tr>
<td>不带VLAN Tag</td>
<td>直接丢弃</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>配置限制和指导<br>当OLT端口下的所有ONU接口类型为Access时，UNI端口操作模式只能为透传模式，这样才能保证ONU接口和用户PC接收的是不带Tag的报文。<br>配置VLAN Trunk模式时，UNI端口允许通过的VLAN总数必须在16个以内，否则该uni vlan-mode命令不能下发给ONU设备。</p>
]]></content>
  </entry>
  <entry>
    <title>Zookeeper单机模式&amp;伪集群模式&amp;集群模式</title>
    <url>/2022/01/13/zookeeper/</url>
    <content><![CDATA[<h2 id="Zookeeper-单机模式-amp-伪集群模式-amp-集群模式"><a href="#Zookeeper-单机模式-amp-伪集群模式-amp-集群模式" class="headerlink" title="Zookeeper 单机模式 &amp; 伪集群模式 &amp; 集群模式"></a>Zookeeper 单机模式 &amp; 伪集群模式 &amp; 集群模式</h2><p>  <strong>ZooKeeper特点</strong>  </p>
<ol>
<li>顺序一致性：以zxid来保证事务的顺序性。  </li>
<li>原子性：以zab保证原子操作，要么成功，要么失败。   </li>
<li>单一视图：客户获取到的数据始终是一致的。  </li>
<li>可靠：以版本实现”写入校验”，保证了数据写入的正确性。</li>
</ol>
<p>ZooKeeper是一个分布式的、开源的分布式应用程序协调服务，可以在分布 式环境中实现应用配置管理、统一命名服务、状态同步服务等功能。 ZooKeeper是一种为分布式应用所设计的高可用、高性能的开源协调服务，它提供了一项基本服务：分布式锁 服务。由于ZooKeeper开源的特性，在其分布式锁实现的基础上，又被摸索出了其它的功用，譬如：配置维 护、组服务、分布式<a href="https://cloud.tencent.com/product/cmq?from=10680">消息队列</a>等等。 ZooKeeper维护了一个类似文件系统的数据结构，其内部每个子目录都被 称作znode（目录节点），与文件系统一样，我们可以自由的增删改查znode。ZooKeeper集群适合搭建在奇数 台机器上。只要集群中半数以上主机处于存活，那么服务就是可用的。 ZooKeeper在配置文件中并没有指定 master和slave，但是，ZooKeeper在工作时，只有一个节点为leader，其余节点为follower，leader是通过内部 的选举机制临时产生的。</p>
<p><strong>ZooKeeper有三种安装方式：单机模式 &amp; 伪集群模式 &amp; 集群模式</strong>   </p>
<p><strong>单机模式：</strong>ZooKeeper以单实例的形式运 行在一台服务器上，适合测试环境。   </p>
<p><strong>伪集群模式：</strong>在一台服务器上跑多个ZooKeeper实例。   </p>
<p><strong>集群模式：</strong> ZooKeeper运行在多台服务器上，适合生产环境。</p>
<h1 id="一、开始部署"><a href="#一、开始部署" class="headerlink" title="一、开始部署"></a><strong>一、开始部署</strong></h1><p><strong>1、单机安装Zookeeper</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装JDK环境</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># tar zxf jdk-8u211-linux-x64.tar.gz -C /usr/local/</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># vim /etc/profile            # 编辑Java变量</span></span><br><span class="line">..........................</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8.0_211</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/usr/<span class="built_in">local</span>/jdk1.8.0_211/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># source /etc/profile           # 执行使配置生效</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># java -version                # 查看是否安装成功</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装zookeeper</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># tar zxf zookeeper-3.4.14.tar.gz -C /usr/local/</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/zookeeper-3.4.14</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$PATH</span>                          <span class="comment"># 加入Java配置的PATH中</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># source /etc/profile</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># cd /usr/local/zookeeper-3.4.14/conf/</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># cp zoo_sample.cfg zoo.cfg</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># mkdir -p /usr/local/zookeeper-3.4.14/data                           # 创建数据目录</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># sed -i &quot;s/dataDir=\/tmp\/zookeeper/dataDir=\/usr\/local\/zookeeper-3.4.14\/data/g&quot; zoo.cfg </span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># zkServer.sh start             # 启动服务</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># netstat -anput | grep 2181           # 确定端口在监听</span></span><br><span class="line">tcp6       0      0 :::2181                 :::*                    LISTEN      4903/java   </span><br></pre></td></tr></table></figure>
<p><strong>1）客户端命令操作</strong>  test</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@zookeeper ~]# zkCli.sh                # 后面不加任何参数默认连接localhost本机的2181端口</span><br><span class="line">Connecting to localhost:2181</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] help         # 显示客户端支持的命令</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /          # 查看当前zk中所包含的内容</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls2 /        # 查看当前zk中的内容及详情</span><br><span class="line">[zookeeper]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create /test1 neirong             # 创建一个节点</span><br><span class="line">Created /test1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /          # 可以看到已经多了一个test1</span><br><span class="line">[zookeeper, test1]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] get /test1        # huo获取节点信息，需写绝对路径</span><br><span class="line">neirong                            # 节点数据信息 </span><br><span class="line">cZxid = 0x2                      # 节点创建时额zxid </span><br><span class="line">ctime = Sat Apr 04 16:15:30 CST 2020               # 节点创建的时间 </span><br><span class="line">mZxid = 0x2</span><br><span class="line">mtime = Sat Apr 04 16:15:30 CST 2020                    # 节点最近一次更新的时间 </span><br><span class="line">pZxid = 0x2</span><br><span class="line">cversion = 0                   # 子结点数据更新次数 </span><br><span class="line">dataVersion = 0                 # 本节点数据更新次数 </span><br><span class="line">aclVersion = 0                 # 节点ACL的更新次数 </span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 7               # 节点数据长度 </span><br><span class="line">numChildren = 0                # 子结点的数量 </span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] set /test1 &quot;gengxin&quot;         # 更新节点数据</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] get /test1           # 可以看到已经更改为新的数据</span><br><span class="line">gengxin</span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] history         # 列出zui最近所使用的命令</span><br><span class="line">0 - help</span><br><span class="line">1 - ls /</span><br><span class="line">2 - ls2 /</span><br><span class="line">3 - create /test1 neirong</span><br><span class="line">4 - ls /</span><br><span class="line">5 - get /test1</span><br><span class="line">6 - set /test1 &quot;gengxin&quot;</span><br><span class="line">7 - get /test1</span><br><span class="line">8 - history</span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] delete /test1         # 删除节点，但是无法删除拥有子节点的 节点</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] rmr /test1           # rmrk可以删除带有子节点的节点</span><br></pre></td></tr></table></figure>
<p><strong>关于zoo.cfg配置参数说明可参考</strong><a href="http://zookeeper.apache.org/doc/r3.4.13/zookeeperAdmin.html"><strong>官方文档</strong></a></p>
<p><strong>2、zookeeper单机伪集群部署</strong> 在一台主机上跑多个zk实例，每个zk实例对应一个独立的配置文件；但是每个配置文件的clientPort &amp; dataDir &amp; dataLogDir绝对不能相同，还需要在dataDir中创建myid文件来指定该dataDir对应的zk实例。 </p>
<p><strong>环境如下：</strong> 这里在一台物理服务器上，部署3个zk实例</p>
<p>zk0    127.0.0.1    2180</p>
<p>zk1    127.0.0.1    2181</p>
<p>zk2    127.0.0.1    2182</p>
<p>1）安装zookeeper</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装好JDK，可参考之前单机安装</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># java -version </span></span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装zookeeper</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># tar zxf zookeeper-3.4.14.tar.gz -C /usr/local/</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/zookeeper-3.4.14</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$PATH</span>                          </span><br><span class="line">[root@zookeeper ~]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建数据目录</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># mkdir -p /usr/local/zookeeper-3.4.14/&#123;data_0,data_1,data_2&#125;</span></span><br><span class="line"><span class="comment">#创建myid文件，并填入ID值</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># echo 0 &gt; /usr/local/zookeeper-3.4.14/data_0/myid</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># echo 1 &gt; /usr/local/zookeeper-3.4.14/data_1/myid</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># echo 2 &gt; /usr/local/zookeeper-3.4.14/data_2/myid</span></span><br><span class="line"><span class="comment">#创建事务日志目录，官方建立尽量给事务日志作单独的磁盘或挂载点，这会极大的提高zk性能</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># mkdir -p /usr/local/zookeeper-3.4.14/&#123;logs_0,logs_1,logs_2&#125;</span></span><br><span class="line"><span class="comment">#配置server0</span></span><br><span class="line">[root@zookeeper ~]<span class="comment"># cd /usr/local/zookeeper-3.4.14/conf/</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># cp zoo_sample.cfg zoo_0.cfg</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># egrep -v &quot;^$|^#&quot; zoo_0.cfg          # 修改配置文件为如下</span></span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper-3.4.14/data_0/</span><br><span class="line">clientPort=2180</span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/zookeeper-3.4.14/logs_0/</span><br><span class="line">server.0=127.0.0.1:2287:3387 </span><br><span class="line">server.1=127.0.0.1:2288:3388 </span><br><span class="line">server.2=127.0.0.1:2289:3389 </span><br><span class="line"><span class="comment">#配置server1</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># cp zoo_0.cfg zoo_1.cfg           # 复制之前的配置文件，修改个别参数</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># vim zoo_1.cfg</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper-3.4.14/data_1/</span><br><span class="line">clientPort=2181</span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/zookeeper-3.4.14/logs_1/</span><br><span class="line"><span class="comment">#配置server2</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># cp zoo_0.cfg zoo_2.cfg</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># vim zoo_2.cfg</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper-3.4.14/data_2/</span><br><span class="line">clientPort=2182</span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/zookeeper-3.4.14/logs_2/</span><br><span class="line">[root@zookeeper conf]<span class="comment"># zkServer.sh start zoo_0.cfg             # 我这里是在conf目录下，所以后面直接接着配置文件，如果不在conf下，则需写全路径</span></span><br><span class="line"><span class="comment">#启动各实例</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># zkServer.sh start zoo_1.cfg </span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># zkServer.sh start zoo_2.cfg </span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># netstat -anput | grep java </span></span><br><span class="line">tcp6       0      0 :::2180                 :::*                    LISTEN      9251/java           </span><br><span class="line">tcp6       0      0 :::2181                 :::*                    LISTEN      9291/java           </span><br><span class="line">tcp6       0      0 :::2182                 :::*                    LISTEN      9334/java    </span><br><span class="line"><span class="comment">#列出JVM</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># jps</span></span><br><span class="line">9377 Jps</span><br><span class="line">9251 QuorumPeerMain</span><br><span class="line">9334 QuorumPeerMain</span><br><span class="line">9291 QuorumPeerMain</span><br><span class="line"><span class="comment">#各实例都启动之后就可以使用客户端进行连接了</span></span><br><span class="line">[root@zookeeper conf]<span class="comment"># zkCli.sh -server 127.0.0.1:2180     # 例</span></span><br></pre></td></tr></table></figure>
<p><strong>关于多个server的配置说明： 这些server表单服务器的条目。列出组成ZooKeeper服务的服务器。当服务器启动 时，它通过在数据目录中查找文件myid来知道它是哪个服务器。该文件包含服务器号。 最后，注意每个服务器 名后面的两个端口号:“2287”和“3387”。对等点使用前一个端口连接到其他对等点。这样的连接是必要的，以便 对等点可以通信，例如，就更新的顺序达成一致。更具体地说，ZooKeeper服务器使用这个端口将追随者连接 到leader。当一个新的领导者出现时，追随者使用这个端口打开一个TCP连接到领导者。由于默认的领导人选举 也使用TCP，我们目前需要另一个端口的领导人选举。这是服务器条目中的第二个端口。</strong></p>
<p><strong>3、 ZooKeeper多机集群部署</strong>  为了获得可靠的zk服务，应该在多台服务器上部署多个zk，只要集群中大多数的zk服务启动了，那么总的zk服 务将是可用的。 在多台主机上搭建ZooKeeper集群的方式，与伪集群几乎是差不多的。</p>
<p><strong>4、 ZooKeeper单机部署多Master</strong> </p>
<p>与伪群集类型 不写Server地址但需修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">admin.serverPort=xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>1.分类和static</title>
    <url>/2021/10/11/Article1/</url>
    <content><![CDATA[<h2 id="1-案例驱动模式"><a href="#1-案例驱动模式" class="headerlink" title="1.案例驱动模式"></a>1.案例驱动模式</h2><h3 id="1-1案例驱动模式概述-理解"><a href="#1-1案例驱动模式概述-理解" class="headerlink" title="1.1案例驱动模式概述 (理解)"></a>1.1案例驱动模式概述 (理解)</h3><p>通过我们已掌握的知识点,先实现一个案例,然后找出这个案例中,存在的一些问题,在通过新知识点解决问题</p>
<h3 id="1-2案例驱动模式的好处-理解"><a href="#1-2案例驱动模式的好处-理解" class="headerlink" title="1.2案例驱动模式的好处 (理解)"></a>1.2案例驱动模式的好处 (理解)</h3><ul>
<li>解决重复代码过多的冗余,提高代码的复用性</li>
<li>解决业务逻辑聚集紧密导致的可读性差,提高代码的可读性</li>
<li>解决代码可维护性差,提高代码的维护性</li>
</ul>
<h2 id="2-分类思想"><a href="#2-分类思想" class="headerlink" title="2.分类思想"></a>2.分类思想</h2><h3 id="2-1分类思想概述-理解"><a href="#2-1分类思想概述-理解" class="headerlink" title="2.1分类思想概述 (理解)"></a>2.1分类思想概述 (理解)</h3><p>分工协作,专人干专事</p>
<h3 id="2-2信息管理系统-理解"><a href="#2-2信息管理系统-理解" class="headerlink" title="2.2信息管理系统 (理解)"></a>2.2信息管理系统 (理解)</h3><ul>
<li><p>Student类  标准学生类,封装键盘录入的学生信息(id , name , age , birthday)</p>
</li>
<li><p>StudentDao类  Dao : (Data Access Object 缩写) 用于访问存储数据的数组或集合</p>
</li>
<li><p>StudentService类  用来进行业务逻辑的处理(例如: 判断录入的id是否存在)</p>
</li>
<li><p>StudentController类  和用户打交道(接收用户需求,采集用户信息,打印数据到控制台)</p>
<p><img src=".\img\01_信息管理系统分类.png" alt="01_信息管理系统分类"></p>
</li>
</ul>
<h2 id="3-分包思想"><a href="#3-分包思想" class="headerlink" title="3.分包思想"></a>3.分包思想</h2><h3 id="3-1分包思想概述-理解"><a href="#3-1分包思想概述-理解" class="headerlink" title="3.1分包思想概述 (理解)"></a>3.1分包思想概述 (理解)</h3><p>如果将所有的类文件都放在同一个包下,不利于管理和后期维护,所以,对于不同功能的类文件,可以放在不同的包下进行管理</p>
<h3 id="3-2包的概述-记忆"><a href="#3-2包的概述-记忆" class="headerlink" title="3.2包的概述 (记忆)"></a>3.2包的概述 (记忆)</h3><ul>
<li><p>包</p>
<p>本质上就是文件夹</p>
</li>
<li><p>创建包</p>
<p>多级包之间使用 “ . “ 进行分割<br>多级包的定义规范：公司的网站地址翻转(去掉www)<br>比如：程序员的网站址为www.itheima.com<br>后期我们所定义的包的结构就是：com.itheima.其他的包名</p>
</li>
<li><p>包的命名规则</p>
<p>字母都是小写</p>
</li>
</ul>
<h3 id="3-3包的注意事项-理解"><a href="#3-3包的注意事项-理解" class="headerlink" title="3.3包的注意事项 (理解)"></a>3.3包的注意事项 (理解)</h3><ul>
<li>package语句必须是程序的第一条可执行的代码 </li>
<li>package语句在一个java文件中只能有一个 </li>
<li>如果没有package,默认表示无包名 </li>
</ul>
<h3 id="3-4类与类之间的访问-理解"><a href="#3-4类与类之间的访问-理解" class="headerlink" title="3.4类与类之间的访问 (理解)"></a>3.4类与类之间的访问 (理解)</h3><ul>
<li><p>同一个包下的访问</p>
<p>不需要导包，直接使用即可</p>
</li>
<li><p>不同包下的访问</p>
<p>1.import 导包后访问</p>
<p>2.通过全类名（包名 + 类名）访问</p>
</li>
<li><p>注意：import 、package 、class 三个关键字的摆放位置存在顺序关系</p>
<p>package 必须是程序的第一条可执行的代码</p>
<p>import 需要写在 package 下面</p>
<p>class 需要在 import 下面</p>
</li>
</ul>
<h2 id="4-信息管理系统"><a href="#4-信息管理系统" class="headerlink" title="4.信息管理系统"></a>4.信息管理系统</h2><h3 id="4-1系统介绍-理解"><a href="#4-1系统介绍-理解" class="headerlink" title="4.1系统介绍 (理解)"></a>4.1系统介绍 (理解)</h3><p><img src=".\img\02_信息管理系统介绍.png" alt="02_信息管理系统介绍"></p>
<h3 id="4-2学生管理系统-应用"><a href="#4-2学生管理系统-应用" class="headerlink" title="4.2学生管理系统 (应用)"></a>4.2学生管理系统 (应用)</h3><h4 id="4-2-1需求说明"><a href="#4-2-1需求说明" class="headerlink" title="4.2.1需求说明"></a>4.2.1需求说明</h4><ul>
<li><p>添加学生: 键盘录入学生信息(id，name，age，birthday)</p>
<p>使用数组存储学生信息,要求学生的id不能重复</p>
</li>
<li><p>删除学生: 键盘录入要删除学生的id值,将该学生从数组中移除,如果录入的id在数组中不存在,需要重新录入</p>
</li>
<li><p>修改学生: 键盘录入要修改学生的id值和修改后的学生信息</p>
<p>将数组中该学生的信息修改,如果录入的id在数组中不存在,需要重新录入</p>
</li>
<li><p>查询学生: 将数组中存储的所有学生的信息输出到控制台</p>
</li>
</ul>
<h4 id="4-2-2实现步骤"><a href="#4-2-2实现步骤" class="headerlink" title="4.2.2实现步骤"></a>4.2.2实现步骤</h4><ul>
<li><p>环境搭建实现步骤<br>| 包                                       | 存储的类                   | 作用                   |<br>| ———————————————————- | ——————————— | —————————— |<br>| com.itheima.edu.info.manager.domain     | Student.java           | 封装学生信息               |<br>| com.itheima.edu.info.manager.dao        | StudentDao.java        | 访问存储数据的数组，进行赠删改查（库管） |<br>| com.itheima.edu.info.manager.service    | StudentService.java    | 业务的逻辑处理（业务员）         |<br>| com.itheima.edu.info.manager.controller | StudentController.java | 和用户打交道（客服接待）         |<br>| com.itheima.edu.info.manager.entry      | InfoManagerEntry.java  | 程序的入口类，提供一个main方法    |</p>
</li>
<li><p>菜单搭建实现步骤 </p>
<ul>
<li>需求<ul>
<li>管理系统菜单搭建</li>
<li>学生管理系统菜单搭建</li>
</ul>
</li>
<li>实现步骤<ol>
<li>展示欢迎页面,用输出语句完成主界面的编写</li>
<li>获取用户的选择,用Scanner实现键盘录入数据</li>
<li>根据用户的选择执行对应的操作,用switch语句完成操作的选择</li>
</ol>
</li>
</ul>
</li>
<li><p>添加功能实现步骤 </p>
<p><img src=".\img\03_添加功能需求分析.png" alt="03_添加功能需求分析"></p>
</li>
</ul>
<ul>
<li><p>添加功能优化:判断id是否存在</p>
<p><img src=".\img\04_判断id是否存在.png" alt="04_判断id是否存在"></p>
</li>
<li><p>查询功能实现步骤</p>
<p><img src=".\img\05_查询功能需求分析.png" alt="05_查询功能需求分析"></p>
</li>
<li><p>删除功能实现步骤</p>
<p><img src=".\img\06_删除功能需求分析.png" alt="06_删除功能需求分析"></p>
</li>
<li><p>修改功能实现步骤 </p>
<p><img src=".\img\07_修改功能需求分析.png" alt="07_修改功能需求分析"></p>
</li>
<li><p>系统优化 </p>
<ul>
<li>把updateStudent和deleteStudentById中录入学生id代码抽取到一个方法(inputStudentId)中<br>该方法的主要作用就是录入学生的id，方法的返回值为String类型</li>
</ul>
</li>
</ul>
<ul>
<li>把addStudent和updateStudent中录入学生信息的代码抽取到一个方法(inputStudentInfo)中<br>该方法的主要作用就是录入学生的信息，并封装为学生对象，方法的返回值为Student类型 </li>
</ul>
<h4 id="4-2-3代码实现"><a href="#4-2-3代码实现" class="headerlink" title="4.2.3代码实现"></a>4.2.3代码实现</h4><p>学生类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id, String name, String age, String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序入口InfoManagerEntry类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfoManagerEntry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 主菜单搭建</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--------欢迎来到信息管理系统--------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您的选择: 1.学生管理  2.老师管理  3.退出&quot;</span>);</span><br><span class="line">            String choice = sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;学生管理&quot;);</span></span><br><span class="line">                    <span class="comment">// 开启学生管理系统</span></span><br><span class="line">                    StudentController studentController = <span class="keyword">new</span> StudentController();</span><br><span class="line">                    studentController.start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;老师管理&quot;</span>);</span><br><span class="line">                    TeacherController teacherController = <span class="keyword">new</span> TeacherController();</span><br><span class="line">                    teacherController.start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;感谢您的使用&quot;</span>);</span><br><span class="line">                    <span class="comment">// 退出当前正在运行的JVM虚拟机</span></span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的输入有误, 请重新输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StudentController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务员对象</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService = <span class="keyword">new</span> StudentService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启学生管理系统, 并展示学生管理系统菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Scanner sc = new Scanner(System.in);</span></span><br><span class="line">        studentLoop:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------欢迎来到 &lt;学生&gt; 管理系统--------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出&quot;</span>);</span><br><span class="line">            String choice = sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;添加&quot;);</span></span><br><span class="line">                    addStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;删除&quot;);</span></span><br><span class="line">                    deleteStudentById();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;修改&quot;);</span></span><br><span class="line">                    updateStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;查询&quot;);</span></span><br><span class="line">                    findAllStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;感谢您使用学生管理系统, 再见!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span> studentLoop;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的输入有误, 请重新输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String updateId = inputStudentId();</span><br><span class="line">        Student newStu = inputStudentInfo(updateId);</span><br><span class="line">        studentService.updateStudent(updateId, newStu);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String delId = inputStudentId();</span><br><span class="line">        <span class="comment">// 3. 调用业务员中的deleteStudentById根据id, 删除学生</span></span><br><span class="line">        studentService.deleteStudentById(delId);</span><br><span class="line">        <span class="comment">// 4. 提示删除成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAllStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 调用业务员中的获取方法, 得到学生的对象数组</span></span><br><span class="line">        Student[] stus = studentService.findAllStudent();</span><br><span class="line">        <span class="comment">// 2. 判断数组的内存地址, 是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (stus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查无信息, 请添加后重试&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 遍历数组, 获取学生信息并打印在控制台</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学号\t\t姓名\t年龄\t生日&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student stu = stus[i];</span><br><span class="line">            <span class="keyword">if</span> (stu != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(stu.getId() + <span class="string">&quot;\t&quot;</span> + stu.getName() + <span class="string">&quot;\t&quot;</span> + stu.getAge() + <span class="string">&quot;\t\t&quot;</span> + stu.getBirthday());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// StudentService studentService = new StudentService();</span></span><br><span class="line">        <span class="comment">// 1. 键盘接收学生信息</span></span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生id:&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="keyword">boolean</span> flag = studentService.isExists(id);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学号已被占用, 请重新输入&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Student stu = inputStudentInfo(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result = studentService.addStudent(stu);</span><br><span class="line">        <span class="comment">// 4. 根据返回的boolean类型结果, 在控制台打印成功\失败</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">inputStudentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生id:&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="keyword">boolean</span> exists = studentService.isExists(id);</span><br><span class="line">            <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的id不存在, 请重新输入:&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">inputStudentInfo</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">        String name = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生年龄:&quot;</span>);</span><br><span class="line">        String age = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生生日:&quot;</span>);</span><br><span class="line">        String birthday = sc.next();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.setId(id);</span><br><span class="line">        stu.setName(name);</span><br><span class="line">        stu.setAge(age);</span><br><span class="line">        stu.setBirthday(birthday);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StudentService类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建StudentDao (库管)</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao = <span class="keyword">new</span> StudentDao();</span><br><span class="line">    <span class="comment">// 添加学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 将学生对象, 传递给StudentDao 库管中的addStudent方法</span></span><br><span class="line">        <span class="comment">// 3. 将返回的boolean类型结果, 返还给StudentController</span></span><br><span class="line">        <span class="keyword">return</span> studentDao.addStudent(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断学号是否存在方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExists</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Student[] stus = studentDao.findAllStudent();</span><br><span class="line">        <span class="comment">// 假设id在数组中不存在</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 遍历数组, 获取每一个学生对象, 准备进行判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student student = stus[i];</span><br><span class="line">            <span class="keyword">if</span>(student != <span class="keyword">null</span> &amp;&amp; student.getId().equals(id))&#123;</span><br><span class="line">                exists = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看学生方法</span></span><br><span class="line">    <span class="keyword">public</span> Student[] findAllStudent() &#123;</span><br><span class="line">        <span class="comment">// 1. 调用库管对象的findAllStudent获取学生对象数组</span></span><br><span class="line">        Student[] allStudent = studentDao.findAllStudent();</span><br><span class="line">        <span class="comment">// 2. 判断数组中是否有学生信息 (有: 返回地址,  没有: 返回null)</span></span><br><span class="line">        <span class="comment">// 思路: 数组中只要存在一个不是null的元素, 那就代表有学生信息</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allStudent.length; i++) &#123;</span><br><span class="line">            Student stu = allStudent[i];</span><br><span class="line">            <span class="keyword">if</span>(stu != <span class="keyword">null</span>)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">// 有信息</span></span><br><span class="line">            <span class="keyword">return</span> allStudent;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 没有信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentById</span><span class="params">(String delId)</span> </span>&#123;</span><br><span class="line">        studentDao.deleteStudentById(delId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(String updateId, Student newStu)</span> </span>&#123;</span><br><span class="line">        studentDao.updateStudent(updateId, newStu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StudentDao类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建学生对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student[] stus = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 添加学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加学生到数组</span></span><br><span class="line">        <span class="comment">//2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2.2 遍历数组取出每一个元素，判断是否是null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student student = stus[i];</span><br><span class="line">            <span class="keyword">if</span>(student == <span class="keyword">null</span>)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="comment">//2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回是否添加成功的boolean类型状态</span></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 装满了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 没有装满, 正常添加, 返回true</span></span><br><span class="line">            stus[index] = stu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看学生方法</span></span><br><span class="line">    <span class="keyword">public</span> Student[] findAllStudent() &#123;</span><br><span class="line">        <span class="keyword">return</span> stus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentById</span><span class="params">(String delId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 查找id在容器中所在的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> index = getIndex(delId);</span><br><span class="line">        <span class="comment">// 2. 将该索引位置,使用null元素进行覆盖</span></span><br><span class="line">        stus[index] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student stu = stus[i];</span><br><span class="line">            <span class="keyword">if</span>(stu != <span class="keyword">null</span> &amp;&amp; stu.getId().equals(id))&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(String updateId, Student newStu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 查找updateId, 在容器中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> index = getIndex(updateId);</span><br><span class="line">        <span class="comment">// 2. 将该索引位置, 使用新的学生对象替换</span></span><br><span class="line">        stus[index] = newStu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3老师管理系统-应用"><a href="#4-3老师管理系统-应用" class="headerlink" title="4.3老师管理系统 (应用)"></a>4.3老师管理系统 (应用)</h3><h4 id="4-3-1需求说明"><a href="#4-3-1需求说明" class="headerlink" title="4.3.1需求说明"></a>4.3.1需求说明</h4><ul>
<li><p>添加老师: 通过键盘录入老师信息(id，name，age，birthday)</p>
<p>使用数组存储老师信息,要求老师的id不能重复</p>
</li>
<li><p>删除老师: 通过键盘录入要删除老师的id值,将该老师从数组中移除,如果录入的id在数组中不存在,需要重新录入</p>
</li>
<li><p>修改老师: 通过键盘录入要修改老师的id值和修改后的老师信息</p>
<p>将数组中该老师的信息修改,如果录入的id在数组中不存在,需要重新录入</p>
</li>
<li><p>查询老师: 将数组中存储的所有老师的信息输出到控制台</p>
</li>
</ul>
<h4 id="4-3-2实现步骤"><a href="#4-3-2实现步骤" class="headerlink" title="4.3.2实现步骤"></a>4.3.2实现步骤</h4><ul>
<li><p>环境搭建实现步骤</p>
<p>| 包                                       | 存储的类                                     | 作用                   |<br>| ———————————————————- | ———————————————————— | —————————— |<br>| com.itheima.edu.info.manager.domain     | Student.java   Teacher.java              | 封装学生信息  封装老师信息       |<br>| com.itheima.edu.info.manager.dao        | StudentDao.java  TeacherDao.java         | 访问存储数据的数组,进行赠删改查（库管） |<br>| com.itheima.edu.info.manager.service    | StudentService.java  TeacherService.java | 业务的逻辑处理（业务员）         |<br>| com.itheima.edu.info.manager.controller | StudentController.java  TeacherController.java | 和用户打交道（客服接待）         |<br>| com.itheima.edu.info.manager.entry      | InfoManagerEntry.java                    | 程序的入口类,提供一个main方法    |</p>
</li>
<li><p>菜单搭建实现步骤</p>
<ol>
<li>展示欢迎页面,用输出语句完成主界面的编写</li>
<li>获取用户的选择,用Scanner实现键盘录入数据</li>
<li>根据用户的选择执行对应的操作,用switch语句完成操作的选择</li>
</ol>
</li>
<li><p>添加功能实现步骤</p>
<p><img src=".\img\10_添加老师功能实现步骤.png" alt="10_添加老师功能实现步骤"></p>
</li>
<li><p>查询功能实现步骤</p>
<p><img src=".\img\11_查询老师功能实现步骤.png" alt="11_查询老师功能实现步骤"></p>
</li>
<li><p>删除功能实现步骤</p>
<p><img src=".\img\12_删除老师功能实现步骤.png" alt="12_删除老师功能实现步骤"></p>
</li>
<li><p>修改功能实现步骤</p>
<p><img src=".\img\13_修改老师功能实现步骤.png" alt="13_修改老师功能实现步骤"></p>
</li>
<li><p>系统优化</p>
<ul>
<li>把updateTeacher和deleteTeacherById中录入老师id代码抽取到一个方法(inputTeacherId)中<br>该方法的主要作用就是录入老师的id,方法的返回值为String类型</li>
<li>把addTeacher和updateTeacher中录入老师信息的代码抽取到一个方法(inputTeacherInfo)中<br>该方法的主要作用就是录入老师的信息,并封装为老师对象,方法的返回值为Teacher类型</li>
</ul>
</li>
</ul>
<h4 id="4-3-3代码实现"><a href="#4-3-3代码实现" class="headerlink" title="4.3.3代码实现"></a>4.3.3代码实现</h4><p>老师类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String id, String name, String age, String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TeacherController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">private</span> TeacherService teacherService = <span class="keyword">new</span> TeacherService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        teacherLoop:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------欢迎来到 &lt;老师&gt; 管理系统--------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您的选择: 1.添加老师  2.删除老师  3.修改老师  4.查看老师  5.退出&quot;</span>);</span><br><span class="line">            String choice = sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;添加老师&quot;);</span></span><br><span class="line">                    addTeacher();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;删除老师&quot;);</span></span><br><span class="line">                    deleteTeacherById();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;修改老师&quot;);</span></span><br><span class="line">                    updateTeacher();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;查看老师&quot;);</span></span><br><span class="line">                    findAllTeacher();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;感谢您使用老师管理系统, 再见!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span> teacherLoop;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的输入有误, 请重新输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = inputTeacherId();</span><br><span class="line"></span><br><span class="line">        Teacher newTeacher = inputTeacherInfo(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用业务员的修改方法</span></span><br><span class="line">        teacherService.updateTeacher(id,newTeacher);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTeacherById</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String id = inputTeacherId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用业务员中的删除方法, 根据id, 删除老师</span></span><br><span class="line">        teacherService.deleteTeacherById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 提示删除成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAllTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 从业务员中, 获取老师对象数组</span></span><br><span class="line">        Teacher[] teachers = teacherService.findAllTeacher();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断数组中是否有元素</span></span><br><span class="line">        <span class="keyword">if</span> (teachers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查无信息, 请添加后重试&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历数组, 取出元素, 并打印在控制台</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学号\t\t姓名\t年龄\t生日&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teachers.length; i++) &#123;</span><br><span class="line">            Teacher t = teachers[i];</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(t.getId() + <span class="string">&quot;\t&quot;</span> + t.getName() + <span class="string">&quot;\t&quot;</span> + t.getAge() + <span class="string">&quot;\t\t&quot;</span> + t.getBirthday());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 接收不存在的老师id</span></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入老师id:&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="comment">// 2. 判断id是否存在</span></span><br><span class="line">            <span class="keyword">boolean</span> exists = teacherService.isExists(id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;id已被占用, 请重新输入:&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Teacher t = inputTeacherInfo(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将封装好的老师对象, 传递给TeacherService继续完成添加操作</span></span><br><span class="line">        <span class="keyword">boolean</span> result = teacherService.addTeacher(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 录入老师id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">inputTeacherId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入id&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="keyword">boolean</span> exists = teacherService.isExists(id);</span><br><span class="line">            <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的id不存在, 请重新输入:&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 录入老师信息, 封装为老师对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Teacher <span class="title">inputTeacherInfo</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入老师姓名:&quot;</span>);</span><br><span class="line">        String name = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入老师年龄:&quot;</span>);</span><br><span class="line">        String age = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入老师生日:&quot;</span>);</span><br><span class="line">        String birthday = sc.next();</span><br><span class="line"></span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        t.setId(id);</span><br><span class="line">        t.setName(name);</span><br><span class="line">        t.setAge(age);</span><br><span class="line">        t.setBirthday(birthday);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TeacherService类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addTeacher</span><span class="params">(Teacher t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> teacherDao.addTeacher(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExists</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取库管对象中的数组</span></span><br><span class="line">        Teacher[] teachers = teacherDao.findAllTeacher();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> exists = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历数组, 取出每一个元素, 进行判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teachers.length; i++) &#123;</span><br><span class="line">            Teacher teacher = teachers[i];</span><br><span class="line">            <span class="keyword">if</span>(teacher != <span class="keyword">null</span> &amp;&amp; teacher.getId().equals(id))&#123;</span><br><span class="line">                exists = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> exists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Teacher[] findAllTeacher() &#123;</span><br><span class="line">        Teacher[] allTeacher = teacherDao.findAllTeacher();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allTeacher.length; i++) &#123;</span><br><span class="line">            Teacher t = allTeacher[i];</span><br><span class="line">            <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> allTeacher;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTeacherById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        teacherDao.deleteTeacherById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTeacher</span><span class="params">(String id, Teacher newTeacher)</span> </span>&#123;</span><br><span class="line">        teacherDao.updateTeacher(id,newTeacher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TeacherDao类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Teacher[] teachers = <span class="keyword">new</span> Teacher[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addTeacher</span><span class="params">(Teacher t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teachers.length; i++) &#123;</span><br><span class="line">            Teacher teacher = teachers[i];</span><br><span class="line">            <span class="keyword">if</span>(teacher == <span class="keyword">null</span>)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            teachers[index] = t;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Teacher[] findAllTeacher() &#123;</span><br><span class="line">        <span class="keyword">return</span> teachers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteTeacherById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 查询id在数组中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> index = getIndex(id);</span><br><span class="line">        <span class="comment">// 2. 将该索引位置的元素, 使用null进行替换</span></span><br><span class="line">        teachers[index] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teachers.length; i++) &#123;</span><br><span class="line">            Teacher t = teachers[i];</span><br><span class="line">            <span class="keyword">if</span>(t != <span class="keyword">null</span> &amp;&amp; t.getId().equals(id))&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTeacher</span><span class="params">(String id, Teacher newTeacher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(id);</span><br><span class="line">        teachers[index] = newTeacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-static关键字"><a href="#5-static关键字" class="headerlink" title="5.static关键字"></a>5.static关键字</h2><h3 id="5-1static关键字概述-理解"><a href="#5-1static关键字概述-理解" class="headerlink" title="5.1static关键字概述 (理解)"></a>5.1static关键字概述 (理解)</h3><p>static 关键字是静态的意思,是Java中的一个修饰符,可以修饰成员方法,成员变量</p>
<h3 id="5-2static修饰的特点-记忆"><a href="#5-2static修饰的特点-记忆" class="headerlink" title="5.2static修饰的特点 (记忆)"></a>5.2static修饰的特点 (记忆)</h3><ul>
<li><p>被类的所有对象共享</p>
<p>是我们判断是否使用静态关键字的条件</p>
</li>
<li><p>随着类的加载而加载，优先于对象存在</p>
<p>对象需要类被加载后，才能创建</p>
</li>
<li><p>可以通过类名调用</p>
<p>也可以通过对象名调用</p>
</li>
</ul>
<h3 id="5-3static关键字注意事项-理解"><a href="#5-3static关键字注意事项-理解" class="headerlink" title="5.3static关键字注意事项 (理解)"></a>5.3static关键字注意事项 (理解)</h3><ul>
<li>静态方法只能访问静态的成员</li>
<li>非静态方法可以访问静态的成员，也可以访问非静态的成员</li>
<li>静态方法中是没有this关键字 </li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JAVA继承</title>
    <url>/2021/10/11/Article2/</url>
    <content><![CDATA[<h2 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h2><h3 id="1-1-继承的实现（掌握）"><a href="#1-1-继承的实现（掌握）" class="headerlink" title="1.1 继承的实现（掌握）"></a>1.1 继承的实现（掌握）</h3><ul>
<li><p>继承的概念</p>
<ul>
<li>继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法</li>
</ul>
</li>
<li><p>实现继承的格式</p>
<ul>
<li>继承通过extends实现</li>
<li>格式：class 子类 extends 父类 { } <ul>
<li>举例：class Dog extends Animal { }</li>
</ul>
</li>
</ul>
</li>
<li><p>继承带来的好处</p>
<ul>
<li>继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。</li>
</ul>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象，调用方法</span></span><br><span class="line">        Fu f = <span class="keyword">new</span> Fu();</span><br><span class="line">        f.show();</span><br><span class="line"></span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.method();</span><br><span class="line">        z.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-继承的好处和弊端（理解）"><a href="#1-2-继承的好处和弊端（理解）" class="headerlink" title="1.2 继承的好处和弊端（理解）"></a>1.2 继承的好处和弊端（理解）</h3><ul>
<li>继承好处<ul>
<li>提高了代码的复用性(多个类相同的成员可以放到同一个类中)</li>
<li>提高了代码的维护性(如果方法的代码需要修改，修改一处即可)</li>
</ul>
</li>
<li>继承弊端<ul>
<li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性</li>
</ul>
</li>
<li>继承的应用场景：<ul>
<li>使用继承，需要考虑类与类之间是否存在is..a的关系，不能盲目使用继承<ul>
<li>is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-Java中继承的特点（掌握）"><a href="#1-3-Java中继承的特点（掌握）" class="headerlink" title="1.3. Java中继承的特点（掌握）"></a>1.3. Java中继承的特点（掌握）</h3><ul>
<li><p>Java中继承的特点</p>
<ol>
<li>Java中类只支持单继承，不支持多继承<ul>
<li>错误范例：class A extends B, C { }</li>
</ul>
</li>
<li>Java中类支持多层继承</li>
</ol>
</li>
<li><p>多层继承示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Granddad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爷爷爱喝酒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Granddad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸爱抽烟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈爱跳舞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 此时，Son类中就同时拥有drink方法以及smoke方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-继承中的成员访问特点"><a href="#2-继承中的成员访问特点" class="headerlink" title="2. 继承中的成员访问特点"></a>2. 继承中的成员访问特点</h2><h3 id="2-1-继承中变量的访问特点（掌握）"><a href="#2-1-继承中变量的访问特点（掌握）" class="headerlink" title="2.1 继承中变量的访问特点（掌握）"></a>2.1 继承中变量的访问特点（掌握）</h3><p>在子类方法中访问一个变量，采用的是就近原则。</p>
<ol>
<li>子类局部范围找</li>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错(不考虑父亲的父亲…)</li>
</ol>
<ul>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();	<span class="comment">// 输出show方法中的局部变量30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-super（掌握）"><a href="#2-2-super（掌握）" class="headerlink" title="2.2 super（掌握）"></a>2.2 super（掌握）</h3><ul>
<li>this&amp;super关键字：<ul>
<li>this：代表本类对象的引用</li>
<li>super：代表父类存储空间的标识(可以理解为父类对象引用)</li>
</ul>
</li>
<li>this和super的使用分别<ul>
<li>成员变量：<ul>
<li>this.成员变量    -   访问本类成员变量</li>
<li>super.成员变量 -   访问父类成员变量</li>
</ul>
</li>
<li>成员方法：<ul>
<li>this.成员方法  - 访问本类成员方法</li>
<li>super.成员方法 - 访问父类成员方法</li>
</ul>
</li>
</ul>
</li>
<li>构造方法：<ul>
<li>this(…)  -  访问本类构造方法</li>
<li>super(…)  -  访问父类构造方法</li>
</ul>
</li>
</ul>
<h3 id="2-3-继承中构造方法的访问特点（理解）"><a href="#2-3-继承中构造方法的访问特点（理解）" class="headerlink" title="2.3 继承中构造方法的访问特点（理解）"></a>2.3 继承中构造方法的访问特点（理解）</h3><p><strong>注意：子类中所有的构造方法默认都会访问父类中无参的构造方法</strong></p>
<p>​    子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super()</p>
<p><strong>问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过使用super关键字去显示的调用父类的带参构造方法</span><br><span class="line">2. 子类通过this去调用本类的其他构造方法,本类其他构造方法再通过super去手动调用父类的带参的构造方法</span><br><span class="line"></span><br><span class="line">注意: this(…)super(…) 必须放在构造方法的第一行有效语句，并且二者不能共存</span><br></pre></td></tr></table></figure>
<h3 id="2-4-继承中成员方法的访问特点（掌握）"><a href="#2-4-继承中成员方法的访问特点（掌握）" class="headerlink" title="2.4 继承中成员方法的访问特点（掌握）"></a>2.4 继承中成员方法的访问特点（掌握）</h3><p>通过子类对象访问一个方法</p>
<ol>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错(不考虑父亲的父亲…)</li>
</ol>
<h3 id="2-5-super内存图（理解）"><a href="#2-5-super内存图（理解）" class="headerlink" title="2.5 super内存图（理解）"></a>2.5 super内存图（理解）</h3><ul>
<li><p>对象在堆内存中，会单独存在一块super区域，用来存放父类的数据 </p>
<p><img src=".\img\01_super内存图.png" alt="01_super内存图"></p>
</li>
</ul>
<h3 id="2-6-方法重写（掌握）"><a href="#2-6-方法重写（掌握）" class="headerlink" title="2.6 方法重写（掌握）"></a>2.6 方法重写（掌握）</h3><ul>
<li>1、方法重写概念<ul>
<li>子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）</li>
</ul>
</li>
<li>2、方法重写的应用场景<ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容</li>
</ul>
</li>
<li>3、Override注解<ul>
<li>用来检测当前的方法，是否是重写的方法，起到【校验】的作用</li>
</ul>
</li>
</ul>
<h3 id="2-7-方法重写的注意事项（掌握）"><a href="#2-7-方法重写的注意事项（掌握）" class="headerlink" title="2.7 方法重写的注意事项（掌握）"></a>2.7 方法重写的注意事项（掌握）</h3><ul>
<li>方法重写的注意事项</li>
</ul>
<ol>
<li>私有方法不能被重写(父类私有成员子类是不能继承的)</li>
<li>子类方法访问权限不能更低(public &gt; 默认 &gt; 私有)</li>
<li>静态方法不能被重写,如果子类也有相同的方法,并不是重写的父类的方法</li>
</ol>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu中show()方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu中method()方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 编译【出错】，子类不能重写父类私有的方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi中show()方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi中method()方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi中method()方法被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-8-权限修饰符-理解"><a href="#2-8-权限修饰符-理解" class="headerlink" title="2.8 权限修饰符 (理解)"></a>2.8 权限修饰符 (理解)</h3><p><img src=".\img\02_权限修饰符.png" alt="02_权限修饰符"></p>
<h3 id="2-9-黑马信息管理系统使用继承改进-掌握"><a href="#2-9-黑马信息管理系统使用继承改进-掌握" class="headerlink" title="2.9 黑马信息管理系统使用继承改进 (掌握)"></a>2.9 黑马信息管理系统使用继承改进 (掌握)</h3><ul>
<li><p>需求</p>
<p>把学生类和老师类共性的内容向上抽取,抽取到出一个 Person 父类,让学生类和老师类继承 Person 类</p>
</li>
<li><p>实现步骤</p>
<ol>
<li><p>抽取Person类</p>
</li>
<li><p>优化StudentController类中，inputStudentInfo方法，将setXxx赋值方式，改进为构造方法初始化</p>
<p>注意：直接修改这种操作方式，不符合我们开发中的一个原则</p>
<p>​    开闭原则 ( 对扩展开放对修改关闭 ) : 尽量在不更改原有代码的前提下以完成需求 </p>
<p>解决：重新创建一个OtherStudentController类</p>
<p>编写新的inputStudentInfo方法</p>
</li>
<li><p>根据StudentController类、OtherStudentController类，向上抽取出BaseStudentController类<br>再让StudentController类、OtherStudentController类，继承BaseStudentController类</p>
</li>
</ol>
</li>
<li><p>代码实现</p>
<p>Person类及学生类和老师类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String id, String name, String age, String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Student类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String id, String name, String age, String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id, name, age, birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Teacher类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String id, String name, String age, String birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id, name, age, birthday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseStudentController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStudentController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务员对象</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService = <span class="keyword">new</span> StudentService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启学生管理系统, 并展示学生管理系统菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Scanner sc = new Scanner(System.in);</span></span><br><span class="line">        studentLoop:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------欢迎来到 &lt;学生&gt; 管理系统--------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出&quot;</span>);</span><br><span class="line">            String choice = sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;添加&quot;);</span></span><br><span class="line">                    addStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;删除&quot;);</span></span><br><span class="line">                    deleteStudentById();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;修改&quot;);</span></span><br><span class="line">                    updateStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;查询&quot;);</span></span><br><span class="line">                    findAllStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;感谢您使用学生管理系统, 再见!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span> studentLoop;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的输入有误, 请重新输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String updateId = inputStudentId();</span><br><span class="line">        Student newStu = inputStudentInfo(updateId);</span><br><span class="line">        studentService.updateStudent(updateId, newStu);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String delId = inputStudentId();</span><br><span class="line">        <span class="comment">// 3. 调用业务员中的deleteStudentById根据id, 删除学生</span></span><br><span class="line">        studentService.deleteStudentById(delId);</span><br><span class="line">        <span class="comment">// 4. 提示删除成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAllStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 调用业务员中的获取方法, 得到学生的对象数组</span></span><br><span class="line">        Student[] stus = studentService.findAllStudent();</span><br><span class="line">        <span class="comment">// 2. 判断数组的内存地址, 是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (stus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查无信息, 请添加后重试&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 遍历数组, 获取学生信息并打印在控制台</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学号\t\t姓名\t年龄\t生日&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student stu = stus[i];</span><br><span class="line">            <span class="keyword">if</span> (stu != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(stu.getId() + <span class="string">&quot;\t&quot;</span> + stu.getName() + <span class="string">&quot;\t&quot;</span> + stu.getAge() + <span class="string">&quot;\t\t&quot;</span> + stu.getBirthday());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// StudentService studentService = new StudentService();</span></span><br><span class="line">        <span class="comment">// 1. 键盘接收学生信息</span></span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生id:&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="keyword">boolean</span> flag = studentService.isExists(id);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学号已被占用, 请重新输入&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Student stu = inputStudentInfo(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result = studentService.addStudent(stu);</span><br><span class="line">        <span class="comment">// 4. 根据返回的boolean类型结果, 在控制台打印成功\失败</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">inputStudentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生id:&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="keyword">boolean</span> exists = studentService.isExists(id);</span><br><span class="line">            <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的id不存在, 请重新输入:&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生信息</span></span><br><span class="line">    <span class="comment">// 开闭原则: 对扩展内容开放, 对修改内容关闭</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Student <span class="title">inputStudentInfo</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StudentController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> <span class="keyword">extends</span> <span class="title">BaseStudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生信息</span></span><br><span class="line">    <span class="comment">// 开闭原则: 对扩展内容开放, 对修改内容关闭</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">inputStudentInfo</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">        String name = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生年龄:&quot;</span>);</span><br><span class="line">        String age = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生生日:&quot;</span>);</span><br><span class="line">        String birthday = sc.next();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.setId(id);</span><br><span class="line">        stu.setName(name);</span><br><span class="line">        stu.setAge(age);</span><br><span class="line">        stu.setBirthday(birthday);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OtherStudentController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherStudentController</span> <span class="keyword">extends</span> <span class="title">BaseStudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生信息</span></span><br><span class="line">    <span class="comment">// 开闭原则: 对扩展内容开放, 对修改内容关闭</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">inputStudentInfo</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">        String name = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生年龄:&quot;</span>);</span><br><span class="line">        String age = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生生日:&quot;</span>);</span><br><span class="line">        String birthday = sc.next();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(id,name,age,birthday);</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h2><h3 id="3-1抽象类的概述（理解）"><a href="#3-1抽象类的概述（理解）" class="headerlink" title="3.1抽象类的概述（理解）"></a>3.1抽象类的概述（理解）</h3><p>​    当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！</p>
<p>​    在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！</p>
<h3 id="3-2抽象类的特点（记忆）"><a href="#3-2抽象类的特点（记忆）" class="headerlink" title="3.2抽象类的特点（记忆）"></a>3.2抽象类的特点（记忆）</h3><ul>
<li><p>抽象类和抽象方法必须使用 abstract 关键字修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象方法的定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p>
</li>
<li><p>抽象类不能实例化</p>
</li>
<li><p>抽象类可以有构造方法</p>
</li>
<li><p>抽象类的子类</p>
<p>​    要么重写抽象类中的所有抽象方法</p>
<p>​    要么是抽象类</p>
</li>
</ul>
<h3 id="3-3抽象类的案例（应用）"><a href="#3-3抽象类的案例（应用）" class="headerlink" title="3.3抽象类的案例（应用）"></a>3.3抽象类的案例（应用）</h3><ul>
<li><p>案例需求</p>
<p>​    定义猫类(Cat)和狗类(Dog)</p>
<p>​    猫类成员方法：eat（猫吃鱼）drink（喝水…）</p>
<p>​    狗类成员方法：eat（狗吃肉）drink（喝水…）</p>
</li>
<li><p>实现步骤</p>
<ol>
<li>猫类和狗类中存在共性内容，应向上抽取出一个动物类（Animal）</li>
<li>父类Animal中，无法将 eat 方法具体实现描述清楚，所以定义为抽象方法</li>
<li>抽象方法需要存活在抽象类中，将Animal定义为抽象类</li>
<li>让 Cat 和 Dog 分别继承 Animal，重写eat方法</li>
<li>测试类中创建 Cat 和 Dog 对象，调用方法测试</li>
</ol>
</li>
<li><p>代码实现</p>
<ul>
<li>动物类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喝水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>猫类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>狗类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        d.eat();</span><br><span class="line">        d.drink();</span><br><span class="line"></span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.drink();</span><br><span class="line">        c.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Animal a = new Animal();</span></span><br><span class="line">        <span class="comment">//a.eat();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-4模板设计模式"><a href="#3-4模板设计模式" class="headerlink" title="3.4模板设计模式"></a>3.4模板设计模式</h3><ul>
<li><p>设计模式</p>
<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
</li>
<li><p>模板设计模式</p>
<p>把抽象类整体就可以看做成一个模板，模板中不能决定的东西定义成抽象方法<br>让使用模板的类（继承抽象类的类）去重写抽象方法实现需求</p>
</li>
<li><p>模板设计模式的优势</p>
<p>模板已经定义了通用结构，使用者只需要关心自己需要实现的功能即可</p>
</li>
<li><p>示例代码</p>
<p>模板类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    作文模板类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositionTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;我的爸爸&gt;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        body();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;啊~ 这就是我的爸爸&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类A</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> <span class="keyword">extends</span> <span class="title">CompositionTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;那是一个秋天, 风儿那么缠绵,记忆中, &quot;</span> +</span><br><span class="line">                <span class="string">&quot;那天爸爸骑车接我放学回家,我的脚卡在了自行车链当中, 爸爸蹬不动,他就站起来蹬...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类B</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tony</span> <span class="keyword">extends</span> <span class="title">CompositionTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public void write()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tom t = <span class="keyword">new</span> Tom();</span><br><span class="line">        t.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-5final（应用）"><a href="#3-5final（应用）" class="headerlink" title="3.5final（应用）"></a>3.5final（应用）</h3><ul>
<li><p>fianl关键字的作用</p>
<ul>
<li>final代表最终的意思，可以修饰成员方法，成员变量，类</li>
</ul>
</li>
<li><p>final修饰类、方法、变量的效果  </p>
<ul>
<li><p>fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）</p>
</li>
<li><p>final修饰方法：该方法不能被重写</p>
</li>
<li><p>final修饰变量：表明该变量是一个常量，不能再次赋值</p>
<ul>
<li><p>变量是基本类型,不能改变的是值</p>
</li>
<li><p>变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的</p>
</li>
<li><p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Student s = <span class="keyword">new</span> Student(<span class="number">23</span>);</span><br><span class="line">  	s = <span class="keyword">new</span> Student(<span class="number">24</span>);  <span class="comment">// 错误</span></span><br><span class="line"> 	s.setAge(<span class="number">24</span>);  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-6黑马信息管理系统使用抽象类改进-应用"><a href="#3-6黑马信息管理系统使用抽象类改进-应用" class="headerlink" title="3.6黑马信息管理系统使用抽象类改进 (应用)"></a>3.6黑马信息管理系统使用抽象类改进 (应用)</h3><ul>
<li><p>需求</p>
<ol>
<li>使用抽象类的思想，将BaseStudentController 中的 inputStudentInfo 方法，定义为抽象方法</li>
<li>将不希望子类重写的方法，使用 final 进行修饰</li>
</ol>
</li>
<li><p>代码实现</p>
<p>BaseStudentController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStudentController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务员对象</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService = <span class="keyword">new</span> StudentService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启学生管理系统, 并展示学生管理系统菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Scanner sc = new Scanner(System.in);</span></span><br><span class="line">        studentLoop:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------欢迎来到 &lt;学生&gt; 管理系统--------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您的选择: 1.添加学生  2.删除学生  3.修改学生  4.查看学生  5.退出&quot;</span>);</span><br><span class="line">            String choice = sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;添加&quot;);</span></span><br><span class="line">                    addStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;删除&quot;);</span></span><br><span class="line">                    deleteStudentById();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;修改&quot;);</span></span><br><span class="line">                    updateStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;查询&quot;);</span></span><br><span class="line">                    findAllStudent();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;感谢您使用学生管理系统, 再见!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span> studentLoop;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的输入有误, 请重新输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String updateId = inputStudentId();</span><br><span class="line">        Student newStu = inputStudentInfo(updateId);</span><br><span class="line">        studentService.updateStudent(updateId, newStu);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deleteStudentById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String delId = inputStudentId();</span><br><span class="line">        <span class="comment">// 3. 调用业务员中的deleteStudentById根据id, 删除学生</span></span><br><span class="line">        studentService.deleteStudentById(delId);</span><br><span class="line">        <span class="comment">// 4. 提示删除成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">findAllStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 调用业务员中的获取方法, 得到学生的对象数组</span></span><br><span class="line">        Student[] stus = studentService.findAllStudent();</span><br><span class="line">        <span class="comment">// 2. 判断数组的内存地址, 是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (stus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查无信息, 请添加后重试&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 遍历数组, 获取学生信息并打印在控制台</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学号\t\t姓名\t年龄\t生日&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student stu = stus[i];</span><br><span class="line">            <span class="keyword">if</span> (stu != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(stu.getId() + <span class="string">&quot;\t&quot;</span> + stu.getName() + <span class="string">&quot;\t&quot;</span> + stu.getAge() + <span class="string">&quot;\t\t&quot;</span> + stu.getBirthday());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// StudentService studentService = new StudentService();</span></span><br><span class="line">        <span class="comment">// 1. 键盘接收学生信息</span></span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生id:&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="keyword">boolean</span> flag = studentService.isExists(id);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学号已被占用, 请重新输入&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Student stu = inputStudentInfo(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将学生对象,传递给StudentService(业务员)中的addStudent方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result = studentService.addStudent(stu);</span><br><span class="line">        <span class="comment">// 4. 根据返回的boolean类型结果, 在控制台打印成功\失败</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">inputStudentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生id:&quot;</span>);</span><br><span class="line">            id = sc.next();</span><br><span class="line">            <span class="keyword">boolean</span> exists = studentService.isExists(id);</span><br><span class="line">            <span class="keyword">if</span> (!exists) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的id不存在, 请重新输入:&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键盘录入学生信息</span></span><br><span class="line">    <span class="comment">// 开闭原则: 对扩展内容开放, 对修改内容关闭</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Student <span class="title">inputStudentInfo</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h2><h3 id="4-1代码块概述-理解"><a href="#4-1代码块概述-理解" class="headerlink" title="4.1代码块概述 (理解)"></a>4.1代码块概述 (理解)</h3><p>在Java中，使用 { } 括起来的代码被称为代码块</p>
<h3 id="4-2代码块分类-理解"><a href="#4-2代码块分类-理解" class="headerlink" title="4.2代码块分类 (理解)"></a>4.2代码块分类 (理解)</h3><ul>
<li><p>局部代码块</p>
<ul>
<li><p>位置: 方法中定义</p>
</li>
<li><p>作用: 限定变量的生命周期，及早释放，提高内存利用率</p>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        局部代码块</span></span><br><span class="line"><span class="comment">            位置：方法中定义</span></span><br><span class="line"><span class="comment">            作用：限定变量的生命周期，及早释放，提高内存利用率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// System.out.println(a);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造代码块</p>
<ul>
<li><p>位置: 类中方法外定义</p>
</li>
<li><p>特点: 每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行</p>
</li>
<li><p>作用: 将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性</p>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        构造代码块:</span></span><br><span class="line"><span class="comment">            位置：类中方法外定义</span></span><br><span class="line"><span class="comment">            特点：每次构造方法执行的时，都会执行该代码块中的代码，并且在构造方法执行前执行</span></span><br><span class="line"><span class="comment">            作用：将多个构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空参数构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带参数构造方法...........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>静态代码块</p>
<ul>
<li><p>位置: 类中方法外定义</p>
</li>
<li><p>特点: 需要通过static关键字修饰，随着类的加载而加载，并且只执行一次</p>
</li>
<li><p>作用: 在类加载的时候做一些数据初始化的操作</p>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态代码块:</span></span><br><span class="line"><span class="comment">            位置：类中方法外定义</span></span><br><span class="line"><span class="comment">            特点：需要通过static关键字修饰，随着类的加载而加载，并且只执行一次</span></span><br><span class="line"><span class="comment">            作用：在类加载的时候做一些数据初始化的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态代码块, 我执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Person类的空参数构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Person类的带...........参数构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="4-3黑马信息管理系统使用代码块改进-应用"><a href="#4-3黑马信息管理系统使用代码块改进-应用" class="headerlink" title="4.3黑马信息管理系统使用代码块改进 (应用)"></a>4.3黑马信息管理系统使用代码块改进 (应用)</h3><ul>
<li><p>需求</p>
<p>使用静态代码块，初始化一些学生数据</p>
</li>
<li><p>实现步骤</p>
<ol>
<li>在StudentDao类中定义一个静态代码块，用来初始化一些学生数据</li>
<li>将初始化好的学生数据存储到学生数组中</li>
</ol>
</li>
<li><p>示例代码</p>
<p>StudentDao类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建学生对象数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student[] stus = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;heima001&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;23&quot;</span>,<span class="string">&quot;1999-11-11&quot;</span>);</span><br><span class="line">        Student stu2 = <span class="keyword">new</span> Student(<span class="string">&quot;heima002&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;24&quot;</span>,<span class="string">&quot;2000-11-11&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stus[<span class="number">0</span>] = stu1;</span><br><span class="line">        stus[<span class="number">1</span>] = stu2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加学生方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加学生到数组</span></span><br><span class="line">        <span class="comment">//2.1 定义变量index为-1，假设数组已经全部存满，没有null的元素</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2.2 遍历数组取出每一个元素，判断是否是null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student student = stus[i];</span><br><span class="line">            <span class="keyword">if</span>(student == <span class="keyword">null</span>)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="comment">//2.3 如果为null，让index变量记录当前索引位置，并使用break结束循环遍历</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回是否添加成功的boolean类型状态</span></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 装满了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 没有装满, 正常添加, 返回true</span></span><br><span class="line">            stus[index] = stu;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看学生方法</span></span><br><span class="line">    <span class="keyword">public</span> Student[] findAllStudent() &#123;</span><br><span class="line">        <span class="keyword">return</span> stus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentById</span><span class="params">(String delId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 查找id在容器中所在的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> index = getIndex(delId);</span><br><span class="line">        <span class="comment">// 2. 将该索引位置,使用null元素进行覆盖</span></span><br><span class="line">        stus[index] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stus.length; i++) &#123;</span><br><span class="line">            Student stu = stus[i];</span><br><span class="line">            <span class="keyword">if</span>(stu != <span class="keyword">null</span> &amp;&amp; stu.getId().equals(id))&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(String updateId, Student newStu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 查找updateId, 在容器中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> index = getIndex(updateId);</span><br><span class="line">        <span class="comment">// 2. 将该索引位置, 使用新的学生对象替换</span></span><br><span class="line">        stus[index] = newStu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
</search>
